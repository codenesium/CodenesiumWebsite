[
{
	"uri": "/documentation/codenesium/appsettings/",
	"title": "AppSettings",
	"tags": [],
	"description": "",
	"content": "There are two appSettings.json files that are generated.\nappSettings.Development.json appSettings.Production.json\nBy default .NET Core looks at the environment variable ASPNETCORE_ENVIRONMENT to determine what environment it\u0026rsquo;s using.\nIf that variable isn\u0026rsquo;t found it will default to production.\n{ \u0026quot;ExternalBaseUrl\u0026quot;: \u0026quot;http://localhost:8000\u0026quot;, -\u0026gt; used to return headers with the correct url when hosted with a proxy \u0026quot;MigrateDatabase\u0026quot;: false, -\u0026gt; migrate the database with entity framework \u0026quot;SecurityEnabled\u0026quot;: false, -\u0026gt; secure all controllers with bearer authentication \u0026quot;JwtSigningKey\u0026quot;: \u0026quot;\u0026quot;, -\u0026gt; used with bearer auth \u0026quot;JwtIssuer\u0026quot;: \u0026quot;\u0026quot;, -\u0026gt; used with bearer auth \u0026quot;JwtAudience\u0026quot;: \u0026quot;\u0026quot;, -\u0026gt; used with bearer auth \u0026quot;ConnectionStrings\u0026quot;: { \u0026quot;ApplicationDbContext\u0026quot;: \u0026quot;\u0026quot; -\u0026gt; connection string for the application }, \u0026quot;Logging\u0026quot;: { \u0026quot;IncludeScopes\u0026quot;: false, \u0026quot;Debug\u0026quot;: { \u0026quot;LogLevel\u0026quot;: { \u0026quot;Default\u0026quot;: \u0026quot;Warning\u0026quot; } }, \u0026quot;Console\u0026quot;: { \u0026quot;LogLevel\u0026quot;: { \u0026quot;Default\u0026quot;: \u0026quot;Warning\u0026quot; } } } }  "
},
{
	"uri": "/documentation/codenesium/authentication/",
	"title": "Authentication",
	"tags": [],
	"description": "",
	"content": ".NET Core Authentication MSDN\nThe summary of how we do authentication is we use bearer tokens as JWTs.\nAuthentication is complicated. There are so many options and ways it can be done. For a generated API we took the easiest and most generic route which is a bearer token. This makes sense for most APIs and web applications.\nYou will need a way to generate tokens. This could be a static token you generate with a long expiration time or it could be by using Identity Server\nSecurity can be enabled/disabled by setting the SecurityEnabled setting in appSettings.json.\nIn ConfigureServices we add the authorize attribute to all controllers\nservices.AddMvcCore(config =\u0026gt; { if(this.Configuration.GetValue\u0026lt;bool\u0026gt;(\u0026quot;SecurityEnabled\u0026quot;)) { var policy = new AuthorizationPolicyBuilder() .RequireAuthenticatedUser() .Build(); config.Filters.Add(new AuthorizeFilter(policy)); } config.Filters.Add(new BenchmarkAttribute()); config.Filters.Add(new NullModelValidaterAttribute()); });  Then we configure the bearer token auth\n(\"SecurityEnabled\"))\" data-lang=\"if(this.Configuration.GetValue(\"SecurityEnabled\"))\"{ var key = Encoding.UTF8.GetBytes(this.Configuration[\u0026#34;JwtSigningKey\u0026#34;]); services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(jwtBearerOptions =\u0026gt; { jwtBearerOptions.TokenValidationParameters = new TokenValidationParameters() { ClockSkew = TimeSpan.FromMinutes(5), ValidateAudience = true, ValidateIssuer = true, ValidateLifetime = true, RequireSignedTokens = true, RequireExpirationTime = true, ValidAudience = this.Configuration[\u0026#34;JwtAudience\u0026#34;], ValidIssuer = this.Configuration[\u0026#34;JwtIssuer\u0026#34;], IssuerSigningKey = new SymmetricSecurityKey(key) }; }); } Then in Configure we enable authentication.\nif(this.Configuration.GetValue\u0026lt;bool\u0026gt;(\u0026quot;SecurityEnabled\u0026quot;)) { app.UseAuthentication(); }  A token looks like this\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1laWQiOiJzdXBwb3J0QGNvZGVuZXNpdW0uY29tIiwicm9sZSI6IlVzZXIiLCJuYmYiOjE1Mjc5NjQ3MTgsImV4cCI6MTUyODU2OTUxOCwiaWF0IjoxNTI3ODc4MzE4LCJpc3MiOiJodHRwczovL3d3dy5jb2RlbmVzaXVtLmNvbSIsImF1ZCI6Imh0dHBzOi8vd3d3LmNvZGVuZXNpdW0uY29tIn0.ITVgY435wLnFF4FlGbZApSUhI31fbpKcEWrjfXa5XE8  You can decrypt a token using a website like https://jwt.io/\n{ \u0026quot;alg\u0026quot;: \u0026quot;HS256\u0026quot;, \u0026quot;typ\u0026quot;: \u0026quot;JWT\u0026quot; } { \u0026quot;nameid\u0026quot;: \u0026quot;support@codenesium.com\u0026quot;, \u0026quot;role\u0026quot;: \u0026quot;User\u0026quot;, \u0026quot;nbf\u0026quot;: 1527964718, \u0026quot;exp\u0026quot;: 1528569518, \u0026quot;iat\u0026quot;: 1527878318, \u0026quot;iss\u0026quot;: \u0026quot;https://www.codenesium.com\u0026quot;, \u0026quot;aud\u0026quot;: \u0026quot;https://www.codenesium.com\u0026quot; }  For more explanation on JSON Web Tokens see https://jwt.io/introduction/\n"
},
{
	"uri": "/documentation/codenesium/autofac/",
	"title": "Autofac",
	"tags": [],
	"description": "",
	"content": "We use Autofac for our Inversion of Control container. ASP.NET Core does have a build in IOC container but we found it had some limitaitons. Mainly it doesn\u0026rsquo;t support registration by convention which means you have to make an explicit registration for everything you add which is a pain. Autofac is only used in the Startup.cs file. Look there for documenation on how we use Autofac.\nAutofac Documentation\nDependency injection in .NET Core\n"
},
{
	"uri": "/documentation/codenesium/azure/",
	"title": "Azure",
	"tags": [],
	"description": "",
	"content": "It\u0026rsquo;s very easy to deploy an app to Azure.\nYou can follow the official documentation with some modification https://docs.microsoft.com/en-us/aspnet/core/tutorials/publish-to-azure-webapp-using-vs?view=aspnetcore-2.2\nYou can skip to the publish step.\nThe project you are publishing is the one that ends with .Web\nChange the DefaultConnection setting when you set up the SQL Server to be ApplicationDbContext.\nUncheck the \u0026ldquo;Apply this migrations on publish\u0026rdquo; checkbox. The migrations in a Codenesium app are enabled with the MigrateDatabase flag in the app settings and are enabled by default.\nWhen the webpage for your app opens you will get a 404 error. You need to add /swagger to the end to see your endpoint.\nThat\u0026rsquo;s it!\n"
},
{
	"uri": "/documentation/codenesium/controllers/",
	"title": "Controllers",
	"tags": [],
	"description": "",
	"content": "We support the standard REST methods and also generate methods for database constraints and foreign keys. Many to many relationships through a reference table can be set as a reference table in the API settings which will automatically create methods on the two reference tables.\n[HttpGet] [Route(\u0026quot;\u0026quot;)] [ReadOnly] [ProducesResponseType(typeof(List\u0026lt;ApiDeviceResponseModel\u0026gt;), 200)] public async virtual Task\u0026lt;IActionResult\u0026gt; All(int? limit, int? offset) [HttpGet] [Route(\u0026quot;{id}\u0026quot;)] [ReadOnly] [ProducesResponseType(typeof(ApiDeviceResponseModel), 200)] [ProducesResponseType(typeof(void), 404)] public async virtual Task\u0026lt;IActionResult\u0026gt; Get(int id) [HttpPost] [Route(\u0026quot;BulkInsert\u0026quot;)] [UnitOfWork] [ProducesResponseType(typeof(List\u0026lt;ApiDeviceResponseModel\u0026gt;), 200)] [ProducesResponseType(typeof(void), 413)] [ProducesResponseType(typeof(ActionResponse), 422)] public virtual async Task\u0026lt;IActionResult\u0026gt; BulkInsert([FromBody] List\u0026lt;ApiDeviceRequestModel\u0026gt; models) [HttpPost] [Route(\u0026quot;\u0026quot;)] [UnitOfWork] [ProducesResponseType(typeof(ApiDeviceResponseModel), 201)] [ProducesResponseType(typeof(CreateResponse\u0026lt;int\u0026gt;), 422)] public virtual async Task\u0026lt;IActionResult\u0026gt; Create([FromBody] ApiDeviceRequestModel model) [HttpPatch] [Route(\u0026quot;{id}\u0026quot;)] [UnitOfWork] [ProducesResponseType(typeof(ApiDeviceResponseModel), 200)] [ProducesResponseType(typeof(void), 404)] [ProducesResponseType(typeof(ActionResponse), 422)] public virtual async Task\u0026lt;IActionResult\u0026gt; Patch(int id, [FromBody] JsonPatchDocument\u0026lt;ApiDeviceRequestModel\u0026gt; patch) [HttpPut] [Route(\u0026quot;{id}\u0026quot;)] [UnitOfWork] [ProducesResponseType(typeof(ApiDeviceResponseModel), 200)] [ProducesResponseType(typeof(void), 404)] [ProducesResponseType(typeof(ActionResponse), 422)] public virtual async Task\u0026lt;IActionResult\u0026gt; Update(int id, [FromBody] ApiDeviceRequestModel model) [HttpDelete] [Route(\u0026quot;{id}\u0026quot;)] [UnitOfWork] [ProducesResponseType(typeof(void), 204)] [ProducesResponseType(typeof(ActionResponse), 422)] public virtual async Task\u0026lt;IActionResult\u0026gt; Delete(int id) byPublicId is a unique index on table device. We also generate methods to get return key records to this table. [HttpGet] [Route(\u0026quot;byPublicId/{publicId}\u0026quot;)] [ReadOnly] [ProducesResponseType(typeof(ApiDeviceResponseModel), 200)] [ProducesResponseType(typeof(void), 404)] public async virtual Task\u0026lt;IActionResult\u0026gt; ByPublicId(Guid publicId)  "
},
{
	"uri": "/documentation/codenesium/databasemigrations/",
	"title": "Database Migrations",
	"tags": [],
	"description": "",
	"content": "I think database migrations can be one of the most frustrating things to deal with. There are several way to handle migrations. My preferred way is to use migration scripts with Fluent Migrator. I just really like having data and schema scripts in the same script so I can handle any situation. There are lots of options though and you should pick the one that works for you.\nOur generated APIs start with a single entity framework migration in the data access project. This is just the create database script from the database you submitted.\nWe do not recommend using this script in a production project. It\u0026rsquo;s really just to get you going if you want to run the api against a database and you don\u0026rsquo;t have your migration strategy worked out. .NET core has excellent migration management tools built in. There are also other options like Fluent Migrator and also Microsoft\u0026rsquo;s DACPAC system.\nThere is an option in the appSettings.json called MigrateDatabase. If you set this to true when the app starts it will apply any migrations to your database.\n"
},
{
	"uri": "/documentation/codenesium/deployment/",
	"title": "Deployment",
	"tags": [],
	"description": "",
	"content": "Deployment in .NET Core is very easy.\nThis article from Microsoft will give you all of the information you need.\nFor our applications you can open a command prompt and navigate to the web directory in the solution.\nFrom there you can run dotnet publish -c release\nThe app wil be built and the output will be in bin\\release\\netcoreapp2.1\\publish\nYou can also build self contained applications with arguments like these\ndotnet publish -c release --self-contained -r win-x64 for Windows\ndotnet publish -c release --self-contained -r linux-x64 for Linux\ndotnet publish -c release --self-contained -r osx-x64 for Mac\nSee .NET Core RID Catalog for a complete list of targets.\n"
},
{
	"uri": "/documentation/codenesium/docker/",
	"title": "Docker",
	"tags": [],
	"description": "",
	"content": " The files required to run the app in a Docker container are in the solution root directory.\nWe target Alpine by default to keep the image s small as possible. The default is a self contained app.\nFor Windows\n Install DockerToolbok from https://docs.docker.com/toolbox/toolbox_install_windows/ Run the Docker QuickStart Terminal app from the start menu. You may want to stop the default machine in Virtual Box and increase the ram. SQL Server requires 2GB ram and the default machine created doesn\u0026rsquo;t have great specs.  Running on SQL Server Run DockerWithSQLServer.bat to run with SQL Server.\nIf you\u0026rsquo;re using Docker Toolbox\n The SQL server will be available at http://192.168.99.100:1433 The Web app is available at http://192.168.99.100  To run this example\ndocker-compose -f docker-compose-sqlserver.yml up  Running on Postgres Run DockerWithPostgres.bat to run with Postgres. This will create a container for Postgres and link it to your .NET Core image.\nIf you\u0026rsquo;re using Docker Toolbox\n The Postgres server will be available at http://192.168.99.100:5433 The Web app is available at http://192.168.99.100  To run this example\ndocker-compose -f docker-compose-postgres.yml up  Changing database providers Change the DatabaseProvider setting in app settings or via environment arguments to MSSQL or POSTRESQL.\nDockerFile  # to run this with docker # build a container named ESPIOT with # docker build -t ESPIOT . # run with # docker run -d -p 8000:8000 --add-host=\u0026quot;localhost:10.0.2.2\u0026quot; --rm --name espiotapp ESPIOT # this will run your app exposed on the docker network and will forward port 8000 on the local machine to port 8000 in the container. # On this machine it's http://192.168.99.100:8000 but it could be different for you. # with the rm option the container will be deleted when it exits # running this command will also expose your local network to the docker container so that localhost from # inside the container will point to your local machine. # see https://stackoverflow.com/questions/30495905/accessing-host-machine-as-localhost-from-a-docker-container-thats-also-inside-a for # info about why 10.0.2.2 makes localhost accessible from the container. FROM microsoft/dotnet:2.2-sdk-alpine AS build WORKDIR /app EXPOSE 80 # copy csproj and restore as distinct layers COPY . ./ WORKDIR /app RUN dotnet publish ESPIOT.Api.Web/ESPIOT.Api.Web.csproj -c Release -o /app/out -r alpine-x64 --self-contained FROM microsoft/dotnet:2.2-runtime-deps-alpine AS runtime WORKDIR /app COPY --from=build /app/out . ENTRYPOINT [\u0026quot;./ESPIOT.Api.Web\u0026quot;]  docker-compose-sqlserver.yml version: '2' services: web: container_name: 'espiot-app' image: 'espiot' build: context: . dockerfile: DockerFile environment: - ASPNETCORE_URLS=http://+:80 - ConnectionStrings__ApplicationDbContext=Server=db;Persist Security Info=False;User ID=sa;Password=Passw0rd;Initial Catalog=espiotMultipleActiveResultSets=True;Connection Timeout=10; - DatabaseProvider=MSSQL - MigrateDatabase=true volumes: - .:/var/www/app ports: - \u0026quot;80:80\u0026quot; depends_on: - \u0026quot;db\u0026quot; networks: - espiot-network extra_hosts: - \u0026quot;localhost:10.0.2.2\u0026quot; db: image: \u0026quot;microsoft/mssql-server-linux\u0026quot; container_name: 'db' environment: SA_PASSWORD: \u0026quot;Passw0rd\u0026quot; ACCEPT_EULA: \u0026quot;Y\u0026quot; ports: - \u0026quot;1433:1433\u0026quot; networks: - espiot-network watchtower: container_name: 'watchtower' image: v2tec/watchtower restart: on-failure volumes: - /var/run/docker.sock:/var/run/docker.sock command: --interval 30 networks: - espiot-network networks: espiot-network: driver: bridge  docker-compose-sqlserver.yml version: '2' services: web: container_name: 'espiot-app' image: 'espiot' build: context: . dockerfile: DockerFile environment: - ASPNETCORE_URLS=http://+:80 - ConnectionStrings__ApplicationDbContext=Host=espiot-db;Persist Security Info=False;User ID=postgres;Password=test;Database=espiot; - DatabaseProvider=POSTGRESQL - MigrateDatabase=true volumes: - .:/var/www/app ports: - \u0026quot;80:80\u0026quot; depends_on: - \u0026quot;db\u0026quot; networks: - espiot-network db: container_name: 'espiot-db' image: postgres:9.6-alpine environment: POSTGRES_USER: postgres POSTGRES_PASSWORD: test POSTGRES_DB: espiot networks: - espiot-network ports: - \u0026quot;5433:5432\u0026quot; restart: always watchtower: container_name: 'watchtower' image: v2tec/watchtower restart: on-failure volumes: - /var/run/docker.sock:/var/run/docker.sock command: --interval 30 networks: - espiot-network volumes: pgdata: networks: espiot-network: driver: bridge  Setup for AWS Lightsail This setup is for ubuntu,.NET Core and Postgres on AWS LightSail. This will install and run the espiot docker application. It will set the docker daemon to run on boot. Your containers should start automatically becuase the docker compose file has the containers set to restart always. Watchtower is also set up. Watchtower is a container that polls docker hub for new images and updates your containers sutomatically. 1. Execute from the AWS CLI. You may get errors if you don't execute them one at a time. aws lightsail create-instances --instance-name \u0026quot;espiot\u0026quot; --availability-zone \u0026quot;us-east-1b\u0026quot; --blueprint-id \u0026quot;ubuntu_18_04\u0026quot; --bundle-id nano_2_0 aws lightsail create-disk --disk-name espiot-data --availability-zone \u0026quot;us-east-1b\u0026quot; --size-in-gb 8 aws lightsail open-instance-public-ports --port-info fromPort=8000,toPort=8000,protocol=TCP --instance-name=\u0026quot;espiot\u0026quot; aws lightsail attach-disk --disk-name espiot-data --instance-name espiot --disk-path /dev/xvdf aws lightsail allocate-static-ip --static-ip-name \u0026quot;espiot-ip\u0026quot; aws lightsail attach-static-ip --static-ip-name \u0026quot;espiot-ip\u0026quot; --instance-name \u0026quot;espiot\u0026quot; aws lightsail get-instance --instance-name \u0026quot;espiot\u0026quot; 2. SSH into the created instance and execute the script below. You can get to the terminal from the LightSail web view. This will create a docker-compose.yml file and a setup.sh script that will set up Docker on the machine and docker-compose up your container. It will also set up the volume you created earlier so that your database can be persisted. You have to presee enter after pasting it to the terminal. sudo echo \u0026quot;version: '2' services: web: container_name: 'espiot-app' image: 'codenesium/espiot' build: context: . dockerfile: DockerFile environment: - ASPNETCORE_URLS=http://+:80 - ConnectionStrings__ApplicationDbContext=Host=espiot-db;Persist Security Info=False;User ID=postgres;Password=test;Database=espiot; - DatabaseProvider=POSTGRESQL - MigrateDatabase=true volumes: - .:/var/www/app ports: - \u0026quot;80:80\u0026quot; restart: always depends_on: - \u0026quot;db\u0026quot; networks: - espiot-network db: container_name: 'espiot-db' image: postgres:9.6-alpine environment: POSTGRES_USER: postgres POSTGRES_PASSWORD: test POSTGRES_DB: espiot networks: - espiot-network ports: - \u0026quot;5433:5432\u0026quot; restart: always volumes: - /database/espiot:/var/lib/postgresql/data watchtower: container_name: 'watchtower' image: v2tec/watchtower restart: on-failure volumes: - /var/run/docker.sock:/var/run/docker.sock command: --interval 30 networks: espiot-network: driver: bridge\u0026quot; \u0026gt;\u0026gt; docker-compose.yml; sudo echo '#!/bin/bash sudo file -s /dev/xvdf \u0026amp;\u0026amp; sudo mkfs -t ext4 /dev/xvdf \u0026amp;\u0026amp; sudo mkdir /database \u0026amp;\u0026amp; sudo mkdir /database/espiot \u0026amp;\u0026amp; sudo mount /dev/xvdf /database/espiot \u0026amp;\u0026amp; sudo rmdir /database/espiot/lost+found \u0026amp;\u0026amp; sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y docker \u0026amp;\u0026amp; sudo apt-get install -y docker-compose \u0026amp;\u0026amp; sudo service docker start \u0026amp;\u0026amp; sudo systemctl enable docker \u0026amp;\u0026amp; docker pull codenesium/espiot \u0026amp;\u0026amp; sudo docker-compose up;' \u0026gt;\u0026gt; setup.sh; chmod 755 setup.sh; sudo sh ./setup.sh;  NGROK If you want to use ngrok to expose your app publicly uncomment this line\nREM \u0026lt;UNCOMMENT TO EXPOSE CONTAINER WITH NGROK\u0026gt; start ngrok http 192.168.99.100:8000  Ngrok is a tunnel service that lets you expose your machine from inside a network to the internet.\nhttps://ngrok.com/\n"
},
{
	"uri": "/documentation/codenesium/entityframework/",
	"title": "Entity Framework",
	"tags": [],
	"description": "",
	"content": " Entities Every table in your database that you want to be exposed to Entity Framework needs a class for it.\nAbstractEntityFrameworkPOCO is an empty abstract class that can be used to add fields to every table in the database like TenantId.\nnamespace AdventureWorksNS.Api.DataAccess { [Table(\u0026quot;ContactType\u0026quot;, Schema=\u0026quot;Person\u0026quot;)] public partial class ContactType: AbstractEntityFrameworkPOCO { public ContactType() {} public void SetProperties( int contactTypeID, DateTime modifiedDate, string name) { this.ContactTypeID = contactTypeID.ToInt(); this.ModifiedDate = modifiedDate.ToDateTime(); this.Name = name; } [Key] [Column(\u0026quot;ContactTypeID\u0026quot;)] public int ContactTypeID { get; set; } [Column(\u0026quot;ModifiedDate\u0026quot;)] public DateTime ModifiedDate { get; set; } [Column(\u0026quot;Name\u0026quot;)] public string Name { get; set; } } }  Related Entities For performance reasons we don\u0026rsquo;t load related entities.\nYou can add this by using .Include on the EF query.\nreturn this.Context.Set\u0026lt;Customer\u0026gt;().Where(predicate).AsQueryable().OrderBy(orderClause).Skip(skip).Take(take).ToList\u0026lt;Customer\u0026gt;();  Changes to\nreturn this.Context.Set\u0026lt;Customer\u0026gt;().Include(st =\u0026gt; st.SalesTerritory.Name).Where(predicate).AsQueryable().OrderBy(orderClause).Skip(skip).Take(take).ToList\u0026lt;Customer\u0026gt;();  Then you have to modify your POCO and the object mapper to map this field to your POCO.\nRelated entities generates crazy SQL and I don\u0026rsquo;t recommend using it.\nUnit of Work Unit of work is accomplished by passing a transaction manager to all controllers and starting a transaction in the request pipeline and then rolling it back if there are errors or committing if there are none.\npublic class EntityFrameworkTransactionCoordinator : ITransactionCoordinator { private DbContext context; public EntityFrameworkTransactionCoordinator(DbContext context) { this.context = context; } public void BeginTransaction() { this.context.Database.BeginTransaction(); } public void CommitTransaction() { if (this.context.Database.CurrentTransaction != null) { this.context.Database.CommitTransaction(); } } public void DisableChangeTracking() { this.context.ChangeTracker.AutoDetectChangesEnabled = false; } public void EnableChangeTracking() { this.context.ChangeTracker.AutoDetectChangesEnabled = true; } public void RollbackTransaction() { if (this.context.Database.CurrentTransaction != null) { this.context.Database.RollbackTransaction(); } } }  Then in the filter that is applied to any methods you want unit of work applied to\npublic class UnitOfWorkAttribute : ActionFilterAttribute { public override void OnActionExecuting(ActionExecutingContext actionContext) { if(!(actionContext.Controller is AbstractApiController)) { throw new Exception(\u0026quot;UnitOfWorkActionFilter can only be applied to controllers that inherit from AbstractApiController\u0026quot;); } AbstractApiController controller = (AbstractApiController)actionContext.Controller; controller.TransactionCooordinator.BeginTransaction(); } public override void OnActionExecuted(ActionExecutedContext actionExecutedContext) { AbstractApiController controller = (AbstractApiController)actionExecutedContext.Controller; if (actionExecutedContext.Exception == null) { try { controller.TransactionCooordinator.CommitTransaction(); } catch (DbUpdateConcurrencyException) { throw; } catch (Exception) { throw; } } else { try { controller.TransactionCooordinator.RollbackTransaction(); } catch (Exception) { throw; } } base.OnActionExecuted(actionExecutedContext); } }  Concurrency Concurrency is accomplished by applying an attribute to your Entity Framework POCO called ConcurrencyCheck. This attribute can be applied to multiple columns.\n[Column(\u0026quot;ModifiedDate\u0026quot;)] [ConcurrencyCheck] public DateTime ModifiedDate { get; set; }  Typically you would use a column called rowversion which is usually a timestamp column. When you retrieve data the column is sent along with the data to the client. When the client makes an update the value is sent and if it has changed in the database since the retrieve then Entity Framework will throw a DbUpdateConcurrencyException exception. You can catch this exception in a filter and return something to the client to tell them to retry or to reload the data.\nIn the UnitOfWorkActionFilter we throw the exception by default. If you need retry functionality you will have to implement it\npublic override void OnActionExecuted(ActionExecutedContext actionExecutedContext) { AbstractApiController controller = (AbstractApiController)actionExecutedContext.Controller; if (actionExecutedContext.Exception == null) { try { controller.TransactionCooordinator.CommitTransaction(); } catch (DbUpdateConcurrencyException) { throw; } catch (Exception) { throw; } }  Read only requests The ReadOnlyAttribute can be applied to any controller methods that only return data. This disables change tracking on the Entity Framework context which drastically increases performance.\npublic class ReadOnlyAttribute : ActionFilterAttribute { public override void OnActionExecuting(ActionExecutingContext actionContext) { if(!(actionContext.Controller is AbstractApiController)) { throw new Exception(\u0026quot;ReadOnlyFilter can only be applied to controllers that inherit from AbstractApiController\u0026quot;); } AbstractApiController controller = (AbstractApiController)actionContext.Controller; controller.TransactionCooordinator.DisableChangeTracking(); } public override void OnActionExecuted(ActionExecutedContext actionExecutedContext) { base.OnActionExecuted(actionExecutedContext); } }  Spatial types We do not currently support spatial types. Entity Framework doesn\u0026rsquo;t support them and we set them to do not generate. When support is added to Entity Framework we will support them.\nPrimary Keys We recommend unique, single field, integer primary keys. There is some contention on this issue but the reasons to design this way outweigh the negatives.\n Storage cost is lower because primary keys are stored in any indexes and foreign keys. Joins with composite keys are nasty. Auto increment is built in. An integer is guaranteed unique. A natural key often starts off unique but this can cause problems later when you realize SSN isn\u0026rsquo;t really unique. To make sure your table really is a relation a composite unique index can accomplish your uniqueness. Changing this index later is cheap. Changing a primary key after the fact stinks. A single field primary key makes a lot of sense for a REST API. A composite key doesn\u0026rsquo;t. Get(field1,field2,field3,field4) They are developer friendly. An alternative is a guid while using NEWSEQUENTIALID(). As a developer I hate dealing with guids in a database. If you need to be able to merge databases later you can add a field to all of the tables called rowguid which is designed for this. Guids eat lots of disk space as primary keys.  Performance hints  Turn off change tracking for read-only requests. Don\u0026rsquo;t select more data than you need. Beware using included columns. Only return the columns you need. We don\u0026rsquo;t do this by default and I think this is a premature optimization. Keep the number of records in the context small by not reading a lot of records.  "
},
{
	"uri": "/documentation/codenesium/filters/",
	"title": "Filters",
	"tags": [],
	"description": "",
	"content": "Filters in ASP.NET Core are useful for making changes in the request pipeline. The ReadOnlyAttribute for example can be applied to controller methods that should only be reading data. It disables the change tracking on the controller.\nFilters can be used to make changes to requests or apply security rules. Basically anything that needs to happen before the request enters the controller or the response after it leave.\nFilters can also be applied to controllers. Filters can be applied globally in the startup.\nThe order of filters does matter.\nSee documentation from Microsoft.\npublic class ReadOnlyAttribute : ActionFilterAttribute { public override void OnActionExecuting(ActionExecutingContext actionContext) { if(!(actionContext.Controller is AbstractApiController)) { throw new Exception(\u0026quot;ReadOnlyFilter can only be applied to controllers that inherit from AbstractApiController\u0026quot;); } AbstractApiController controller = (AbstractApiController)actionContext.Controller; controller.TransactionCooordinator.DisableChangeTracking(); } public override void OnActionExecuted(ActionExecutedContext actionExecutedContext) { base.OnActionExecuted(actionExecutedContext); } }  "
},
{
	"uri": "/documentation/getting-started/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": "Install the client to get started.\nRegister for an account.\nCreate a new project.\nFill out the project name, select a project type and set a local directory to sync souce code to.\nOpen the Database Forge. This tool lets you design a database schema from scratch or you can load a database you already have. For this example we are going to load Adventure Works.\nWith the Database Forge open you can add your schema and the tables and columns. You can also load a schema from a SQL Server or PostgreSQL instance by clicking in the menu and selecting load from database. Fill out your credentials and you should get a notification if you are able to connect. Click Complete Schema Editing to return to the Codenesium App. You may get errors on this step about\n missing primary keys invalid primary key column types composite primary keys other validation errors  In most cases it\u0026rsquo;s possible to still generate with validation errors but some tables or columns may be disabled.\nOptionally click settings to make changes to your schema. You can think of these settings as overriding the database schema. Don\u0026rsquo;t make changes in the Database Forge that don\u0026rsquo;t really exist in your database. The settings editor is where most of your editing should happen.\nFrom the settings editor you can make various changes to the project.\n Rename tables and columns. Add virtual foreign keys and constraints. Disable generation of tables and columns. Add custom attributes on the generated controller and controller methods. Disable methods in the controller if for example you only want the Get method exposed. Change the CLR type of the column. Set the default value on your models. Add boolean conversion for database columns that are a char with a value of \u0026lsquo;Y\u0026rsquo; and \u0026lsquo;N\u0026rsquo; to be a boolean in the generated code. Enable columns in the response or request.  Click Complete Editing when you are through Click deploy to generate your project. It can take a few minutes to generate, build, test and deploy your project. Please be patient. If an error occurs we are notified and will attempt to reach out to you to resolve the problem. Click the playground link to see the Swagger enpoint on the playground server. The source code will be synced to the directory you provided. Use the swagger enpoint to test out your API. When your project is regenerated the database is reset. Add migrations using the migrations button to create a SQL script that will run on every deployment. This is useful to populate your database with test data.\n If you have any issues let us know at support@codenesium.com  "
},
{
	"uri": "/documentation/codenesium/healthchecks/",
	"title": "Health Checks",
	"tags": [],
	"description": "",
	"content": "Generated APIs have a health check endpoint that by default checks that the database is accessible and that we can query it.\nThe path is api/health.\nHelath checks are enabled in startup.cs.\n"
},
{
	"uri": "/documentation/codenesium/logging/",
	"title": "Logging",
	"tags": [],
	"description": "",
	"content": "MSDN\nThere are two places to configure logging. This section is only used by Entity Framework and is set by default to write the Entity Framework SQL queries to the console.\npublic static readonly LoggerFactory LoggerFactory = new LoggerFactory(new List\u0026lt;ILoggerProvider\u0026gt;() { new ConsoleLoggerProvider((category, level) =\u0026gt; category == DbLoggerCategory.Database.Command.Name \u0026amp;\u0026amp; level == LogLevel.Information, true), new DebugLoggerProvider((category, level) =\u0026gt; category == DbLoggerCategory.Database.Command.Name \u0026amp;\u0026amp; level == LogLevel.Information) });  The second place sets up the logging from the config file.\npublic virtual void SetupLogging(IServiceCollection services) { services.AddLogging(logBuilder =\u0026gt; logBuilder .AddConfiguration(this.Configuration.GetSection(\u0026quot;Logging\u0026quot;)) .AddConsole() .AddDebug()); }  Loggers are injected all over the generated system. If you need to add a logger to a class simply add\nILogger\u0026lt;YOUR_CLASS_NAME\u0026gt; logger  to any constructor.\n"
},
{
	"uri": "/documentation/codenesium/performance/",
	"title": "Performance",
	"tags": [],
	"description": "",
	"content": "With our architecture it\u0026rsquo;s easy to achieve \u0026gt; 5000 requests per second with 10 year old hardware.\nThis test was ran from localhost on the server. It returns a single address record. Comparable performance was found running from another machine. The server was CPU bound by dotnet.exe while running this example.\nWindows Server 2012 SQL Server 2014 8GB ram. 12 Cores CPU X5650 @ 2.67GHz AdventureWorks2012 database from https://github.com/Microsoft/sql-server-samples/releases/tag/adventureworks Tested with bombardier from https://github.com/codesenberg/bombardier C:\\Users\\Administrator\\Downloads\u0026gt;bombardier http://localhost/testSite/api/addres ses/1 --header=\u0026quot;api-version:1.0\u0026quot; --duration=60s --connections=125 Bombarding http://localhost/testSite/api/addresses/1 for 1m0s using 125 connecti ons [========================================================================] 1m0s Done! Statistics Avg Stdev Max Reqs/sec 5129.00 1963.66 76022.81 Latency 24.48ms 3.41ms 241.01ms HTTP codes: 1xx - 0, 2xx - 306391, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 2.70MB/s  Windows Server 2012 SQL Server 2014 8GB ram. 2 Cores CPU X5650 @ 2.67GHz AdventureWorks2012 database from https://github.com/Microsoft/sql-server-samples/releases/tag/adventureworks Tested with bombardier from https://github.com/codesenberg/bombardier C:\\Users\\Administrator\\Downloads\u0026gt;bombardier http://localhost/testSite/api/addres ses/1 --header=\u0026quot;api-version:1.0\u0026quot; --duration=60s --connections=125 Bombarding http://localhost/testSite/api/addresses/1 for 1m0s using 125 connecti ons [========================================================================] 1m0s Done! Statistics Avg Stdev Max Reqs/sec 970.43 1138.21 19506.83 Latency 132.26ms 87.41ms 3.14s HTTP codes: 1xx - 0, 2xx - 56720, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 512.57KB/s  "
},
{
	"uri": "/documentation/codenesium/playground-server/",
	"title": "Playground Server",
	"tags": [],
	"description": "",
	"content": "When you generate a project and have the playground server enabled we build your project and deploy it to a server.\nEvery time you deploy a new database is created.\nYou can create a single migration in the client that is ran. This is useful to seed your test data.\nThe database for your application is limited to 50 MB on disk and is CPU throttled.\nThis deployed app is really just for testing that we can generate your application and should not be used for anything other than that.\nFor an example visit http://www.codenesium.com:8080/user7303b0f5161f4149bf2959a488d359feNebula/swagger\n"
},
{
	"uri": "/documentation/codenesium/project-structure/",
	"title": "Project Structure",
	"tags": [],
	"description": "",
	"content": "Solution view Web project view "
},
{
	"uri": "/documentation/codenesium/repositories/",
	"title": "Repositories",
	"tags": [],
	"description": "",
	"content": "Our repositories look like a standard repository.\nWe do generate a separate repository for each object. This is a violation of DRY. However, a generic repository can be an anti-pattern and I like the flexibility of a repository per object.\nSome design choices I made.\n We don\u0026rsquo;t expose a method that takes a Func like you will see on a lot of repositories using Entity Framework. I made this choice because I don\u0026rsquo;t want the repository to be so coupled to Entity Framework is can never be changed. Parsing a Func into something Dapper can understand would be challenging if not impossible. To accomplish this we only except objects or primitives as parameters. This creates a strong contract for the repository instead of a generic method that takes a Func. This does require adding methods for everything you want to add.  This could me mitigated by using the Strategy pattern and moving the queries to a separate, testable class. It is something I\u0026rsquo;m going to explore in the future.\nYou can add a generic where method to the derived class to add this yourself.\nRepositories are by default broken out by table. As your business domain starts making sense you should move things around to fit your domain. A domain would rarely just need access to one table. Luckily with Entity Framework we have access to the entire context so you can access anything you need from one repository. Repositories Can be combined or molded to fit your needs and I would expect what is initially generated to change.\npublic interface IDeviceRepository { Task\u0026lt;Device\u0026gt; Create(Device item); Task Update(Device item); Task Delete(int id); Task\u0026lt;Device\u0026gt; Get(int id); Task\u0026lt;List\u0026lt;Device\u0026gt;\u0026gt; All(int limit = int.MaxValue, int offset = 0); Task\u0026lt;Device\u0026gt; ByPublicId(Guid publicId); Task\u0026lt;List\u0026lt;DeviceAction\u0026gt;\u0026gt; DeviceActions(int deviceId, int limit = int.MaxValue, int offset = 0); }  "
},
{
	"uri": "/documentation/codenesium/windowsservice/",
	"title": "Running as Windows Service",
	"tags": [],
	"description": "",
	"content": "Every generated project has the required code to run as a windows service.\nIn Program.cs remove the line CreateWebHostBuilderForServiceIDE(args).Build().Run();\nUncomment the commented out code.\nMake sure you\u0026rsquo;re targeting windows in the csproj.\nWhen running in the IDE the project will run from the console like normal. With this code uncommented when running from the command line the default is to be a windows service. You can still run the executable as a console app by passing \u0026ndash;console on the command line. Otherwise you can use SC create line normal to create your service.\n public class Program { public static void Main(string[] args) { CreateWebHostBuilderForServiceIDE(args).Build().Run(); /* uncomment to support hosting as a windows service bool isService = !(Debugger.IsAttached || args.Contains(\u0026quot;--console\u0026quot;)); if (isService) { CreateWebHostBuilderForService(args).Build().RunAsCustomService(); } else { CreateWebHostBuilderForServiceIDE(args).Build().Run(); } */ } public static IWebHostBuilder CreateWebHostBuilderForServiceIDE(string[] args) { return WebHost.CreateDefaultBuilder(args) .UseStartup\u0026lt;Startup\u0026gt;() .UseKestrel() .UseUrls(\u0026quot;http://0.0.0.0:8000\u0026quot;); } public static IWebHostBuilder CreateWebHostBuilderForService(string[] args) { string pathToExe = Process.GetCurrentProcess().MainModule.FileName; string pathToContentRoot = Path.GetDirectoryName(pathToExe); return WebHost.CreateDefaultBuilder(args) .ConfigureAppConfiguration((context, config) =\u0026gt; { }) .UseContentRoot(pathToContentRoot) .UseStartup\u0026lt;Startup\u0026gt;() .UseKestrel() .UseUrls(\u0026quot;http://0.0.0.0:8000\u0026quot;); } }  "
},
{
	"uri": "/documentation/codenesium/services/",
	"title": "Services",
	"tags": [],
	"description": "",
	"content": " Services are where the business logic lives.\nThey take models from the Web layer and validate then call repositories to make changes to your database.\nThe default generated APID doesn\u0026rsquo;t contain business logic for your domain. It only has what the database can tell us.\nIf your models require other logic then this is where that is implemented. It can be in validators or in methods in the service it\u0026rsquo;s really up to you.\nWe have DTOs that the entity framework entities are mapped to and then we map those to request or response models for the API. This may seem redundant but the idea is that you\u0026rsquo;re going to want to implement some kind of Aggregate Root type objects at this level and you can use the DTO\u0026rsquo;s in those to implement your custom business logic.\npublic interface IAddressService { Task\u0026lt;CreateResponse\u0026lt;ApiAddressResponseModel\u0026gt;\u0026gt; Create( ApiAddressRequestModel model); Task\u0026lt;ActionResponse\u0026gt; Update(int addressID, ApiAddressRequestModel model); Task\u0026lt;ActionResponse\u0026gt; Delete(int addressID); Task\u0026lt;ApiAddressResponseModel\u0026gt; Get(int addressID); Task\u0026lt;List\u0026lt;ApiAddressResponseModel\u0026gt;\u0026gt; All(int skip = 0, int take = int.MaxValue, string orderClause = \u0026quot;\u0026quot;); Task\u0026lt;ApiAddressResponseModel\u0026gt; GetAddressLine1AddressLine2CityStateProvinceIDPostalCode(string addressLine1,string addressLine2,string city,int stateProvinceID,string postalCode); Task\u0026lt;List\u0026lt;ApiAddressResponseModel\u0026gt;\u0026gt; GetStateProvinceID(int stateProvinceID); }  Mapping We map entities to DTOs then we map DTOs to response models. You can replace this with AutoMapper. It\u0026rsquo;s my opinion that you can\u0026rsquo;t use AutoMapper unless you have 100% test coverage where it\u0026rsquo;s going to be used. It makes refactoring difficult because the mapping is done with reflection and leads to runtime bugs when field names change.\n"
},
{
	"uri": "/documentation/codenesium/swagger/",
	"title": "Swagger",
	"tags": [],
	"description": "",
	"content": "We use SwashBuckle to provide swagger support.\nThere is a lot of configuration options available for swagger.\nLook in Startup.cs to see everything Swagger related.\nFor a demo view http://www.codenesium.com:8080/user7303b0f5161f4149bf2959a488d359feNebula/swagger/\nTo generate a client for a swagger endpoint in many languages see http://editor.swagger.io/\nservices.AddSwaggerGen(o =\u0026gt; { o.ResolveConflictingActions(apiDescriptions =\u0026gt; apiDescriptions.First()); // resolve the IApiVersionDescriptionProvider service // note: that we have to build a temporary service provider here because one has not been created yet var provider = services.BuildServiceProvider().GetRequiredService\u0026lt;IApiVersionDescriptionProvider\u0026gt;(); // add a swagger document for each discovered API version // note: you might choose to skip or document deprecated API versions differently foreach (var description in provider.ApiVersionDescriptions) { o.SwaggerDoc(description.GroupName, CreateInfoForApiVersion(description)); } // add a custom operation filter which sets default values o.OperationFilter\u0026lt;SwaggerDefaultValues\u0026gt;(); // integrate xml comments // o.IncludeXmlComments( XmlCommentsFilePath ); if (this.Configuration.GetValue\u0026lt;bool\u0026gt;(\u0026quot;SecurityEnabled\u0026quot;)) { var security = new Dictionary\u0026lt;string, IEnumerable\u0026lt;string\u0026gt;\u0026gt; { {\u0026quot;Bearer\u0026quot;, new string[] { }}, }; o.AddSecurityRequirement(security); o.AddSecurityDefinition(\u0026quot;Bearer\u0026quot;, new ApiKeyScheme() { In = \u0026quot;header\u0026quot;, Description = \u0026quot;Please insert JWT prefixed with Bearer\u0026quot;, Name = \u0026quot;Authorization\u0026quot;, Type = \u0026quot;apiKey\u0026quot; }); } });  "
},
{
	"uri": "/documentation/codenesium/testing/",
	"title": "Testing",
	"tags": [],
	"description": "",
	"content": "Codenesium ships with a unit/integration test suite. Our philosophy is that tests are key to making software than can evolve with changing requirements.\nAll projects have 80%+ coverage. Where the coverage is missing is by design.\nWe use popular libraries for testing. Testing with this stack is fun!\nxUnit This is unit testing framework.\nMoq Mocking library for testing.\nFluent Assertions Assertion library that allows checking of assertions with fluent syntax.\nCoverlet App that generated a code coverage report.\nWe are also a huge fan of NCrunch. If you haven\u0026rsquo;t checked it out you should.\nA sample test looks like this\n[Trait(\u0026quot;Type\u0026quot;, \u0026quot;Unit\u0026quot;)] [Trait(\u0026quot;Table\u0026quot;, \u0026quot;Device\u0026quot;)] [Trait(\u0026quot;Area\u0026quot;, \u0026quot;Repositories\u0026quot;)] public partial class DeviceRepositoryTests { [Fact] public async void All() { Mock\u0026lt;ILogger\u0026lt;DeviceRepository\u0026gt;\u0026gt; loggerMoc = DeviceRepositoryMoc.GetLoggerMoc(); ApplicationDbContext context = DeviceRepositoryMoc.GetContext(); var repository = new DeviceRepository(loggerMoc.Object, context); Device entity = new Device(); context.Set\u0026lt;Device\u0026gt;().Add(entity); await context.SaveChangesAsync(); var record = await repository.All(); record.Should().NotBeEmpty(); } }  "
},
{
	"uri": "/documentation/codenesium/tooling/",
	"title": "Tooling",
	"tags": [],
	"description": "",
	"content": "Codenesium has tooling to help with your development process.\nGenerated files that are expected to not be modified and generated over are named with a .g.cs extension.\nGenerated files that are meant to be modified have a .cs extension.\nAll generated files have a hash appended to the source code\n/*\u0026lt;Codenesium\u0026gt; \u0026lt;Hash\u0026gt;a3b4672d5db2dbc17932846fa4116b4c\u0026lt;/Hash\u0026gt; \u0026lt;/Codenesium\u0026gt;*/  This hash is a MD5 hash of the contents of the file. If you modify the file in any way the hash will be invalid. When the generation is ran again we don\u0026rsquo;t overwrite any files that don\u0026rsquo;t match their hash. This allows you to make changes and be confident Codenesium isn\u0026rsquo;t going to overwrite them.\nFiles with a .cs extension have the hash and can me modified by you but the hash is there in case you want to prevent modification of those files too.\nSome files like the includes.cs files in each project do not have a hash. These files are not regenerated after the first pass and can me modified.\nIn the application menu there is a modified files report. This report will scan your project directory for any files that have a Codenesium hash that doesn\u0026rsquo;t match and returns the output.\nMenu-\u0026gt;Modified Files Report\nWhen this report is ran a ModifiedFilesReport.txt file is generated and written to the Codenesium folder in the project. If you want to add exceptions so that modified files you intend to be modified no longer show in this report then you can add entries into the ModifiedSilExceptions.txt file. One entry per line relative to the project root directory.\nFor a project named TestProject you could add an entry like\nTESTPROJECT.API.CLIENT\\APICLIENT\\ABSTRACTAPICLIENT.G.CS  to removed this file from the modified files report.\nThe point of this is to be able to see when someone modifies files they shouldn\u0026rsquo;t have in source control and this lets you keep as much of the generation intact as possible so you can regenerate in the future.\n"
},
{
	"uri": "/documentation/codenesium/validation/",
	"title": "Validation",
	"tags": [],
	"description": "",
	"content": "We use Fluent Validation for our validation needs.\nFluent Validation is an amazing validation library that makes validation fun.\nRules are assigned to models using fluent syntax.\nThis is a complex example but I want to show how flexible it is and how clear the rules are.\npublic virtual void AddressLine1Rules() { this.RuleFor(x =\u0026gt; x.AddressLine1).NotNull(); this.RuleFor(x =\u0026gt; x).MustAsync(this.BeUniqueGetAddressLine1AddressLine2CityStateProvinceIDPostalCode).When(x =\u0026gt; x ?.AddressLine1 != null).WithMessage(\u0026quot;Violates unique constraint\u0026quot;).WithName(nameof(ApiAddressRequestModel.AddressLine1)); this.RuleFor(x =\u0026gt; x.AddressLine1).Length(0, 60); } private async Task\u0026lt;bool\u0026gt; BeUniqueGetAddressLine1AddressLine2CityStateProvinceIDPostalCode(ApiAddressRequestModel model, CancellationToken cancellationToken) { var record = await this.AddressRepository.GetAddressLine1AddressLine2CityStateProvinceIDPostalCode(model.AddressLine1,model.AddressLine2,model.City,model.StateProvinceID,model.PostalCode); return record == null; }  I think the idea is to keep the model validation separate from the service which is what we do. We inject model validators into the services and that helps us keep single responsibility intact.\nFluent validation is usually applied using filters on controllers. This works fine but we\u0026rsquo;re trying to keep all of the validation in the service layer.\nThe initial API just has rules that we can infer from the database like length, nullability and unique constraints. As you apply business rules you can add them to the existing validators or add new ones separate from the database type validation. I feel like it makes more sense to add your validation to the existing ones by leveraging the derived validator class to override the generated validators.\nIt is also possible, although not recommended, to remove these validators and just let the entity framework validation bubble up errors.\n"
},
{
	"uri": "/documentation/codenesium/",
	"title": "Documentation",
	"tags": [],
	"description": "",
	"content": "This is the documentation for the Codenesium platform.\nUse the menu to find what you\u0026rsquo;re looking for.\n"
},
{
	"uri": "/documentation/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "See a mistake? Email us at support@codenesium.com\n"
},
{
	"uri": "/documentation/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Codenesium\n"
},
{
	"uri": "/documentation/documenation/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "\r\rCodenesium Documentation\rCodenesium :: Codenesium Documentation\r\rvar baseurl = \"\\/documentation\";\r\r\rvar i=new Image();i.src=\"https://alb.reddit.com/t.gif?q=CAAHAAABAAoACQAAAAACbiNWAA==\u0026s=kaLZRyF0BEqBfro3pLVnd01-R0k5I7C8ba0hXD7Tsbc=\";\r\r\r\r\r\rwindow.dataLayer = window.dataLayer || [];\rfunction gtag(){dataLayer.push(arguments);}\rgtag('js', new Date());\rgtag('config', 'AW-851792048');\r\r\r(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\rm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\rga('create', 'UA-71359140-1', 'auto');\rga('send', 'pageview');\r\r\r.nav-select\r{\rmargin-top:15px;\r}\rheader:after\r{\rbackground:none;\r}\rheader\r{\rbackground-color: #2C3E50;\r}\r\r\r\rCodenesium\n\r\u0026#9776;\r\r\r\r\r\r\r\rGetting started\r\r\r\rDocumentation\r\r\r\r\rAppSettings\r\r\r\r\rAuthentication\r\r\r\r\rAutofac\r\r\r\r\rAzure\r\r\r\r\rControllers\r\r\r\r\rDatabase Migrations\r\r\r\r\rDeployment\r\r\r\r\rDocker\r\r\r\r\rEntity Framework\r\r\r\r\rFilters\r\r\r\r\rHealth Checks\r\r\r\r\rLogging\r\r\r\r\rPerformance\r\r\r\r\rPlayground Server\r\r\r\rProject Structure\r\r\r\rRepositories\r\r\r\r\rRunning as Windows Service\r\r\r\r\rServices\r\r\r\r\rSwagger\r\r\r\r\rTesting\r\r\r\r\rTooling\r\r\r\r\rValidation\r\r\r\r\r\r\rArticles\r\r\r\rASP.NET Core API with Entity Framework\r\r\r\rChaos to SOLID\r\r\r\r\r\rSubscription\r\r\r\r\r\r\rNavigation : Getting started Documentation - AppSettings\r- Authentication\r- Autofac\r- Azure\r- Controllers\r- Database Migrations\r- Deployment\r- Docker\r- Entity Framework\r- Filters\r- Health Checks\r- Logging\r- Performance\r- Playground Server\r- Project Structure - Repositories\r- Running as Windows Service\r- Services\r- Swagger\r- Testing\r- Tooling\r- Validation\rArticles\rSubscription\r\r\r\r navigation\r\rWhat is Codenesium? Codenesium is a mythical element that when applied to your software project allows your team to prototype and ship high quality software faster.\nHow does it work? Install the Codenesium application on your dev machine and load a schema from a database you already have. You can also use our handy database schema editing tool the Database Forge to create a schema. After that deploy your app and we take care of the REST.\nWe do several things\n Generate the source code for a ASP.NET Core REST API built on n-tier architecture with tests. Deploy your application to a playground server for testing. Download the source code to your machine ready to run. All you need is the .NET Core SDK installed. Detect when you have modified generated files and never step on them when you regenerate.  Why would I pay for this? Generating an API is nice but the long term value is being able to add fields and make changes to your database and regenerate. We fully expect most people to stop using the generation at some point and from then on make manual changes. That\u0026rsquo;s ok. You still have a well designed API that is still similar to the architecture you would have used anyway. What we\u0026rsquo;re offering is incredibly rapid prototyping on your API. You can focus on React or Angular or whatever front end technology is the flavor of the month while your API is ready to go. You can focus on business requirements instead of architecture and as the database rapidly changes as your requirements evolve you can simply regenerate the API. For many small projects you could ship what we generate and call it done.\nCode generation is bad though. It certainly can be. We\u0026rsquo;re not selling you a code generator. We\u0026rsquo;re selling you an application that an engineer could spend months writing. Ready to ship with tests. We\u0026rsquo;re always learning and applying feedback from other engineers to continuously improve what we\u0026rsquo;re generating. Iterating like that lets us save your team from a long list of roadblocks by combining the knowledge of the crowd into one architecture that is Codenesium.\nWhere can I see the code? The best place will be our samples page on github.\nWhere can I submit feedback? We are not experts and don\u0026rsquo;t claim to be. There are definitely better ways to write some of this code. We will try to be open with what trade-offs we made or any deficiencies we see.\nHaving said that we love feedback. We are absolutely interested in hearing better ways of writing code and if we think your way is better we guarantee it will go into the product. Software architecture is hard. We can\u0026rsquo;t stay on top of everything and feedback is the shortest path to knowing what needs improvement.\nGetting started\r\r\r\r\r\rImprove this page\r\r\r\rSee a mistake? Email us at support@codenesium.com\n\r\r\r\r\r\r"
},
{
	"uri": "/documentation/articles/entity-framework-example/",
	"title": "ASP.NET Core API with Entity Framework",
	"tags": [],
	"description": "",
	"content": "This article is a how-to on building a simple API with ASP.NET Core and Entity Framework.\nThe source can be found on Github at https://github.com/codenesium/ASP.NET-Core-Examples/tree/master/EntityFrameworkExample\nThe example uses a very simple database I call IOT which could be used to control IOT devices via an API.\nThis example is missing lots of important stuff. This list isn\u0026rsquo;t comprehensive.\n Security Versioning Dependency Injection Validation Configuration Logging Tests Entity Framework Configuration Swagger Migrations  For examples on how to create a production API please see https://github.com/codenesium/samples\nTo generate an API for your database see https://www.codenesium.com/\nThis is the database.\nUSE [master] GO CREATE DATABASE [IOT] GO CREATE TABLE [dbo].[Device]( [id] [int] IDENTITY(1,1) NOT NULL, [name] [varchar](90) NOT NULL, [publicId] [uniqueidentifier] NOT NULL, CONSTRAINT [PK_Device] PRIMARY KEY CLUSTERED ( [id] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] GO SET ANSI_PADDING OFF GO /****** Object: Table [dbo].[DeviceAction] Script Date: 6/25/2018 5:27:36 PM ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO SET ANSI_PADDING ON GO CREATE TABLE [dbo].[DeviceAction]( [id] [int] IDENTITY(1,1) NOT NULL, [deviceId] [int] NOT NULL, [name] [varchar](90) NOT NULL, [value] [varchar](4000) NOT NULL, CONSTRAINT [PK_Action] PRIMARY KEY CLUSTERED ( [id] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] GO SET ANSI_PADDING OFF GO /****** Object: Index [IX_Device] Script Date: 6/25/2018 5:27:36 PM ******/ CREATE UNIQUE NONCLUSTERED INDEX [IX_Device] ON [dbo].[Device] ( [publicId] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] GO /****** Object: Index [IX_DeviceAction_DeviceId] Script Date: 6/25/2018 5:27:36 PM ******/ CREATE NONCLUSTERED INDEX [IX_DeviceAction_DeviceId] ON [dbo].[DeviceAction] ( [deviceId] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] GO ALTER TABLE [dbo].[DeviceAction] WITH CHECK ADD CONSTRAINT [FK_DeviceAction_Device] FOREIGN KEY([deviceId]) REFERENCES [dbo].[Device] ([id]) GO ALTER TABLE [dbo].[DeviceAction] CHECK CONSTRAINT [FK_DeviceAction_Device] GO USE [master] GO ALTER DATABASE [IOT] SET READ_WRITE GO  The first thing you need to do is create this database in SQL server on your machine.\nIf you don\u0026rsquo;t have SQL Server you can download it here\nNext create a new ASP.NET Core web project\nSet the options. We\u0026rsquo;re going to use an empty project.\nInstall the Entity Framework package from nuget.\nInstall-Package Microsoft.EntityFrameworkCore.SqlServer  Entity Framework will reverse engineer everything you need from your exising database. You can also build your model in Entity Framework and it can create your database. In this example we\u0026rsquo;re going to use an existing database. To scaffold the Entity Framework context run the database script on a database and then from the package manager console run this command with your server info filled in.\nScaffold-DbContext \u0026quot;Server=localhost;Persist Security Info=False;User ID=test;Password=Passw0rd;Initial Catalog=IOT;MultipleActiveResultSets=True;Connection Timeout=300;\u0026quot; Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models  Next add your controller. The all method will return all of the devices in the database.\nusing EntityFrameworkExample.Models; using Microsoft.AspNetCore.Mvc; using System.Linq; using System.Threading.Tasks; namespace EntityFrameworkExample { [Route(\u0026quot;api/devices\u0026quot;)] public class DevicesController : Controller { [HttpGet] public async virtual Task\u0026lt;IActionResult\u0026gt; All() { using (var context = new IOTContext()) { var devices = context.Device.ToList(); return this.Ok(devices); } } } }  Startup.cs is where all of your application setup occurs. We\u0026rsquo;re adding\nservices.AddMvc();  and\napp.UseMvc();  These are required to add routing and the other things needed for controllers to function.\nusing Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.DependencyInjection; namespace EntityFrameworkExample { public class Startup { // This method gets called by the runtime. Use this method to add services to the container. // For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940 public void ConfigureServices(IServiceCollection services) { services.AddMvc(); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseMvc(); } } }  Run the project.\nThe API endpoint is\nhttp://localhost:5000/api/devices  The json response from our API\n[{\u0026quot;id\u0026quot;:1,\u0026quot;name\u0026quot;:\u0026quot;asqGjFBZso\u0026quot;,\u0026quot;publicId\u0026quot;:\u0026quot;92025a7d-65ec-5106-b03c-0f19718814b6\u0026quot;,\u0026quot;deviceAction\u0026quot;:[]},{\u0026quot;id\u0026quot;:2,\u0026quot;name\u0026quot;:\u0026quot;sOTeyZVZqt\u0026quot;,\u0026quot;publicId\u0026quot;:\u0026quot;222d1adf-3da1-5c62-82c1-a01a3a4ae060\u0026quot;,\u0026quot;deviceAction\u0026quot;:[]},{\u0026quot;id\u0026quot;:1002,\u0026quot;name\u0026quot;:\u0026quot;string\u0026quot;,\u0026quot;publicId\u0026quot;:\u0026quot;00000000-0000-0000-0000-000000000000\u0026quot;,\u0026quot;deviceAction\u0026quot;:[]}]  Included here are the other files in the project. These are all generated so I won\u0026rsquo;t go into detail on how they work.\nProgram.cs\nusing Microsoft.AspNetCore; using Microsoft.AspNetCore.Hosting; namespace EntityFrameworkExample { public class Program { public static void Main(string[] args) { CreateWebHostBuilder(args).Build().Run(); } public static IWebHostBuilder CreateWebHostBuilder(string[] args) =\u0026gt; WebHost.CreateDefaultBuilder(args) .UseStartup\u0026lt;Startup\u0026gt;(); } }  The Entity Framework context\nusing System; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata; namespace EntityFrameworkExample.Models { public partial class IOTContext : DbContext { public IOTContext() { } public IOTContext(DbContextOptions\u0026lt;IOTContext\u0026gt; options) : base(options) { } public virtual DbSet\u0026lt;Device\u0026gt; Device { get; set; } public virtual DbSet\u0026lt;DeviceAction\u0026gt; DeviceAction { get; set; } protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { if (!optionsBuilder.IsConfigured) { #warning To protect potentially sensitive information in your connection string, you should move it out of source code. See http://go.microsoft.com/fwlink/?LinkId=723263 for guidance on storing connection strings. optionsBuilder.UseSqlServer(\u0026quot;Server=localhost;Persist Security Info=False;User ID=test;Password=Passw0rd;Initial Catalog=IOT;MultipleActiveResultSets=True;Connection Timeout=300;\u0026quot;); } } protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity\u0026lt;Device\u0026gt;(entity =\u0026gt; { entity.HasIndex(e =\u0026gt; e.PublicId) .HasName(\u0026quot;IX_Device\u0026quot;) .IsUnique(); entity.Property(e =\u0026gt; e.Id).HasColumnName(\u0026quot;id\u0026quot;); entity.Property(e =\u0026gt; e.Name) .IsRequired() .HasColumnName(\u0026quot;name\u0026quot;) .HasMaxLength(90) .IsUnicode(false); entity.Property(e =\u0026gt; e.PublicId).HasColumnName(\u0026quot;publicId\u0026quot;); }); modelBuilder.Entity\u0026lt;DeviceAction\u0026gt;(entity =\u0026gt; { entity.HasIndex(e =\u0026gt; e.DeviceId) .HasName(\u0026quot;IX_DeviceAction_DeviceId\u0026quot;); entity.Property(e =\u0026gt; e.Id).HasColumnName(\u0026quot;id\u0026quot;); entity.Property(e =\u0026gt; e.DeviceId).HasColumnName(\u0026quot;deviceId\u0026quot;); entity.Property(e =\u0026gt; e.Name) .IsRequired() .HasColumnName(\u0026quot;name\u0026quot;) .HasMaxLength(90) .IsUnicode(false); entity.Property(e =\u0026gt; e.Value) .IsRequired() .HasColumnName(\u0026quot;value\u0026quot;) .HasMaxLength(4000) .IsUnicode(false); entity.HasOne(d =\u0026gt; d.Device) .WithMany(p =\u0026gt; p.DeviceAction) .HasForeignKey(d =\u0026gt; d.DeviceId) .OnDelete(DeleteBehavior.ClientSetNull) .HasConstraintName(\u0026quot;FK_DeviceAction_Device\u0026quot;); }); } } }  Our Device entity\nusing System; using System.Collections.Generic; namespace EntityFrameworkExample.Models { public partial class Device { public Device() { DeviceAction = new HashSet\u0026lt;DeviceAction\u0026gt;(); } public int Id { get; set; } public string Name { get; set; } public Guid PublicId { get; set; } public ICollection\u0026lt;DeviceAction\u0026gt; DeviceAction { get; set; } } }  "
},
{
	"uri": "/documentation/articles/",
	"title": "Articles",
	"tags": [],
	"description": "",
	"content": "This is a collection of articles on .NET Core and related technologies.\n"
},
{
	"uri": "/documentation/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/documentation/articles/chaos-to-solid/",
	"title": "Chaos to SOLID",
	"tags": [],
	"description": "",
	"content": " This article is a journey on the path from chaos to SOLID.\nCode can be found on Github at https://github.com/codenesium/ASP.NET-Core-Examples/tree/master/ChaosToSOLID\nWhat is chaos?  Chaos is a project that everyone is scared to touch and requires a week to add a field.\n It\u0026rsquo;s no tests or even worse bad tests that frustrate developers, slow the development process and don\u0026rsquo;t help quality. It\u0026rsquo;s late nights fixing bugs that should have been caught with tests. It\u0026rsquo;s fixing the same bug over and over because it keeps getting reintroduced. It\u0026rsquo;s a unit test suite that takes hours to run and is constantly broken by changes in other parts of the system. It\u0026rsquo;s the wall on a new project that you hit when the quality issues start dragging you down.  We\u0026rsquo;re going to take a set of requirements and implement the project multiple times as we move from a naive attempt to a complete solution. Along the way we will explore how to unit test and various tools that make testing easier. Our stack is ASP.NET Core.\nWhat is SOLID? This is straight from Wikipedia\nSingle responsibility principle a class should have only a single responsibility (i.e. changes to only one part of the software\u0026rsquo;s specification should be able to affect the specification of the class).\nOpen/closed principle \u0026ldquo;software entities  should be open for extension, but closed for modification.\u0026rdquo;\nLiskov substitution principle \u0026ldquo;objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.\u0026rdquo; See also design by contract.\nInterface segregation principle \u0026ldquo;many client-specific interfaces are better than one general-purpose interface.\u0026rdquo;[4]\nDependency inversion principle one should \u0026ldquo;depend upon abstractions, [not] concretions.\u0026rdquo;\nBut what do these things mean in practice?\nWhat happens when you don\u0026rsquo;t write SOLID code?\n\u0026ldquo;a class should have only a single responsibility\u0026rdquo; sounds simple but what is a responsibility?\nResponsibility could mean interface with the database. Does that mean you\u0026rsquo;re SOLID if you have a repository class with 500 methods? By applying SOLID principles to your software you can accommodate change and be confident that the software you write today will work in the future.\nThe task You are a software engineer at a bank and you have been tasked with building a service that runs on the backend.\nThe web service that runs the bank website will call your web service with details to create the account in the database. There are two methods you need to implement. They need a method to create an account and a method to retrieve it by id. As you can already guess these are just methods you would see on a REST API. We\u0026rsquo;re going to focus on these two methods for the duration of the project.\nIteration 1 [Route(\u0026quot;api/[controller]\u0026quot;)] [ApiController] public class AccountControllerV1 : ControllerBase { /// \u0026lt;summary\u0026gt; /// This system runs as a service in a bank. The website backend that our customers use enter /// their account information and then that service calls our service to actually create the accounts for the customers. /// Create a method that takes an account name and customer id and creates an account for them. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;account\u0026quot;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpPost] public IActionResult Create(Account account) { if(string.IsNullOrWhiteSpace(account.Name)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } if (string.IsNullOrWhiteSpace(account.Name)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } if (string.IsNullOrWhiteSpace(account.SSN)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } using (var context = new ApplicationDbContext()) { if (context.Accounts.Any(a =\u0026gt; a.Name == account.Name)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } account.DateCreated = DateTime.Now; context.Accounts.Add(account); context.SaveChanges(); return Ok(account); } } }  And the unit tests too because someone read on a blog that unit tests are good.\n[Fact] public void Test_Account_Create() { AccountControllerV1 controller = new AccountControllerV1(); IActionResult result = controller.Create(new Account() { Id = 1, Name = \u0026quot;Test\u0026quot;, SSN=\u0026quot;078-05-1120\u0026quot; }); Assert.True(result is OkObjectResult); var response = (result as OkObjectResult); var responseItem = response.Value as Account; Assert.True(responseItem.Id == 1); Assert.True(responseItem.Name == \u0026quot;Test\u0026quot;); Assert.True(responseItem.SSN == \u0026quot;078-05-1120\u0026quot;); Assert.True(responseItem.DateCreated != null); }  Technically this satisfies our requirements. We have 100% test coverage. We\u0026rsquo;re even validating the input because we\u0026rsquo;re good developers.\nI want to express to you that this will lead to chaos\u0026hellip;let me explain why.\nThis code is not testable. It will never be testable written like this and it will devolve into a mess over time as requirements change.\nThis sounds like a contradiction because we clearly have a test.\n Our method is validating and interacting with the database. It\u0026rsquo;s easy to understand now. Imagine that this table grows to require 20 fields. That\u0026rsquo;s not a unrealistic number. Now imagine how much validation is going to be required on those 20 fields. At least 20 field type checks and then any database validation required for your business rules. How many lines can be put in this method? 100? 500? At that point how easy would it be to go make a change in the method and be very confident you didn\u0026rsquo;t break anything?\n We\u0026rsquo;re not testing the individual things inside the create method. We\u0026rsquo;re testing all of it. Because we don\u0026rsquo;t really have a choice. A failure in validation or in the database is all the same to this test. What\u0026rsquo;s the difference between an empty name error and a record already exists error? How would we even set those tests up? We would have to create a model for each test while having to think about the various rules that have to pass to test the one thing we want to test. We can mock the Entity Framework context because .NET core is awesome but that\u0026rsquo;s not a unit test. Do we really want to deal with EntityFramework every time we need to test this method?\n This test is testing that all of the fields are correct. That means when we change or add a field we\u0026rsquo;re going to have to update every one of these tests. There could be lots and lots of tests. Good luck with that. This is a violation of DRY\n We\u0026rsquo;re creating our Account model with inline object initialization. This leads to bugs because when we add a field to this class we won\u0026rsquo;t get a compile time error that we\u0026rsquo;re not setting the new fields. This is a violation of the open/closed principle.\n We\u0026rsquo;re relying on DateTime.Now to set the dateCreated field. How can we test that?\n  Iteration 2 In this iteration we\u0026rsquo;re going to change our controller to use dependency injection. This is application of the D in SOLID. Classes should have their dependencies injected so that the functionality of the class can be verified with mocks.\n/// \u0026lt;summary\u0026gt; /// We've changed our account controller to use an injected database context. /// \u0026lt;/summary\u0026gt; [Route(\u0026quot;api/[controller]\u0026quot;)] [ApiController] public class AccountControllerV2 : ControllerBase { private ApplicationDbContext context; public AccountControllerV2(ApplicationDbContext context) { this.context = context; } [HttpPost] public IActionResult Create(Account account) { if (string.IsNullOrWhiteSpace(account.Name)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } if (context.Accounts.Any(a =\u0026gt; a.Name == account.Name)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } if (string.IsNullOrWhiteSpace(account.SSN)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } account.DateCreated = DateTime.Now; this.context.Accounts.Add(account); this.context.SaveChanges(); return Ok(account); } }  [Fact] public void Test_Account_Create() { DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test1\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); AccountControllerV2 controller = new AccountControllerV2(context); IActionResult result = controller.Create(new Account() { Id = 1, Name = \u0026quot;Checking\u0026quot;, SSN = \u0026quot;078-05-1120\u0026quot; }); Assert.True(result != null); Assert.True(context.Accounts.Count() == 1); Assert.True(context.Accounts.First().Id == 1); Assert.True(context.Accounts.First().Name == \u0026quot;Checking\u0026quot;); Assert.True(context.Accounts.First().DateCreated != null); Assert.True(context.Accounts.First().SSN == \u0026quot;078-05-1120\u0026quot;); } [Fact] public void Test_Account_Create_With_Validation() { //setup DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test2\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); AccountControllerV2 controller = new AccountControllerV2(context); //act IActionResult result = controller.Create(new Account() { Id = 1, Name = \u0026quot;Checking\u0026quot;, SSN=\u0026quot;078-05-1120\u0026quot; }); Assert.True(result != null); // the result isn't null Assert.True(context.Accounts.Count() == 1); // the result has the count we expect Assert.True(context.Accounts.First().Id == 1); // the record has the id we expect Assert.True(context.Accounts.First().Name == \u0026quot;Checking\u0026quot;); // it has the right name Assert.True(context.Accounts.First().DateCreated != null); // we saved a date Assert.True(context.Accounts.First().SSN == \u0026quot;078-05-1120\u0026quot;); // test that creating a blank name returns a 422 code IActionResult result2 = controller.Create(new Account() { Id = 1, Name = \u0026quot;\u0026quot; }); Assert.True((result2 as StatusCodeResult).StatusCode == 422); // test that creating duplicate names returns 4222 IActionResult resultUnique = controller.Create(new Account() { Id = 2, Name = \u0026quot;Checking1\u0026quot; }); IActionResult resultUniqueTest = controller.Create(new Account() { Id = 2, Name = \u0026quot;Checking1\u0026quot; }); Assert.True((result2 as StatusCodeResult).StatusCode == 422); }  In Iteration 2 we changed our controller to take the Entity Framework context as a constructor argument. This is the D in SOLID. Dependency inversion means classes that depend on other classes to operate have those classes injected instead of creating them. There are inversion of control systems that handle creating whatever instance a class required. This project uses Autofac but there are several IOC libraries available. By injecting the Entity Framework context we can verify things happened to the context like records were created.\nIn Test_Account_Create we are now testing that a record actually got added to the context after calling create on the controller.\nIn Test_Account_Create_With_Validation we test that creating an account with a blank name returns a 422(Unprocessable Entity) code and then we test that creating an account with the same name as an existing return a 422 error.\nWe have 100% test coverage. What are some issues with this code?\nOur tests are growing! How big will they go? They\u0026rsquo;re complicated too.\n Test_Account_Create_With_Validation is testing lots of stuff. A failure anywhere in this test will require some digging to understand what the problem really is.\n We\u0026rsquo;re still using Entity Framework which is slow in a test context. Unit tests should be crazy fast so you get instant feedback when you\u0026rsquo;re working in the code.\n We\u0026rsquo;re still checking every field which is brittle as we discussed.\n When we add 20 more fields to this table how long will this test be? 1k lines?\n We\u0026rsquo;re still relying on DateTime.Now.\n  Iteration 3 Requirement change A new requirement came in and we have to change this controller to call an external service to validate this customer\u0026rsquo;s SSN with the FBI counter-terrorism database. We can\u0026rsquo;t let people on the terror list open bank accounts so we are going to call the FBI service with the user\u0026rsquo;s social security number to determine if we should let them open an account.\nusing System; using System.Collections.Generic; using System.Linq; using System.Net.Http; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; namespace Chaos.Controllers { /// \u0026lt;summary\u0026gt; /// A new requirement came in and we have to change this controller to use an external service to validate this customer with the FBI counter-terrorism database. /// \u0026lt;/summary\u0026gt; [Route(\u0026quot;api/[controller]\u0026quot;)] [ApiController] public class AccountControllerV3 : ControllerBase { private ApplicationDbContext context; public AccountControllerV3(ApplicationDbContext context) { this.context = context; } [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Create(Account account) { if (string.IsNullOrWhiteSpace(account.Name)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } if (context.Accounts.Any(a =\u0026gt; a.Name == account.Name)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } if (string.IsNullOrWhiteSpace(account.SSN)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } if(!(await this.VerifyWithFBI(account.SSN))) { return new StatusCodeResult((int)System.Net.HttpStatusCode.BadRequest); } context.Accounts.Add(account); context.SaveChanges(); return Ok(account); } private async Task\u0026lt;bool\u0026gt; VerifyWithFBI(string ssn) { HttpClient client = new HttpClient(); string response = await client.GetStringAsync(\u0026quot;https://jsonplaceholder.typicode.com/posts/1\u0026quot;); if(!string.IsNullOrWhiteSpace(response)) { return true; } else { return false; } } } }   [Fact] public async void Test_Account_Create_With_Validation_Cant_Test_FBI_Service() { //setup DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test2\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); AccountControllerV3 controller = new AccountControllerV3(context); //act IActionResult result = await controller.Create(new Account() { Id = 1, Name = \u0026quot;Checking\u0026quot;, SSN= \u0026quot;000-05-1120\u0026quot; }); Assert.True(result != null); // the result isn't null Assert.True(context.Accounts.Count() == 1); // the result has the count we expect Assert.True(context.Accounts.First().Id == 1); // the record has the id we expect Assert.True(context.Accounts.First().Name == \u0026quot;Checking\u0026quot;); // it has the right name Assert.True(context.Accounts.First().DateCreated != null); // we saved a date Assert.True(context.Accounts.First().SSN == \u0026quot;000-05-1120\u0026quot;); // test that creating a blank name returns a 422 code IActionResult result2 = await controller.Create(new Account() { Id = 1, Name = \u0026quot;\u0026quot; }); Assert.True((result2 as StatusCodeResult).StatusCode == 422); // test that creating duplicate names returns 4222 IActionResult resultUnique = await controller.Create(new Account() { Id = 2, Name = \u0026quot;Checking1\u0026quot; }); IActionResult resultUniqueTest = await controller.Create(new Account() { Id = 2, Name = \u0026quot;Checking1\u0026quot; }); Assert.True((result2 as StatusCodeResult).StatusCode == 422); //How can we test that our FBI service worked or failed? We really can't. }  We\u0026rsquo;ve added the FBI service method. Ignoring the fact this is just a test json endpoint what\u0026rsquo;s wrong with this method?\n Our endpoint is hard-coded. Is there any way to mock this method in tests for our controller? Probably not because it doesn\u0026rsquo;t use an interface and the method isn\u0026rsquo;t virtual. This is just an FYI but HttpClient should be used as a singleton in .NET core. It will use up all of the sockets on a machine used like this. You should not use using statements with it either.  Iteration 4 In this iteration we\u0026rsquo;re going to make our FBI service testable in our controller so that if it returns false we can test our controller returns the right status code.\n[Route(\u0026quot;api/[controller]\u0026quot;)] [ApiController] public class AccountControllerV4 : ControllerBase { private ApplicationDbContext context; private IFBIService fbiService; public AccountControllerV4(ApplicationDbContext context, IFBIService fbiService) { this.context = context; this.fbiService = fbiService; } [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Create(Account account) { if (string.IsNullOrWhiteSpace(account.Name)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } if (context.Accounts.Any(a =\u0026gt; a.Name == account.Name)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } if (string.IsNullOrWhiteSpace(account.SSN)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.UnprocessableEntity); } if (!(await this.fbiService.VerifyWithFBI(account.SSN))) { return new StatusCodeResult((int)System.Net.HttpStatusCode.BadRequest); } context.Accounts.Add(account); context.SaveChanges(); return Ok(account); } } public interface IFBIService { Task\u0026lt;bool\u0026gt; VerifyWithFBI(string ssn); } public class FBIService : IFBIService { public async Task\u0026lt;bool\u0026gt; VerifyWithFBI(string ssn) { HttpClient client = new HttpClient(); string response = await client.GetStringAsync(\u0026quot;https://jsonplaceholder.typicode.com/posts/1\u0026quot;); if (!string.IsNullOrWhiteSpace(response)) { return true; } else { return false; } } }  public async void Test_Account_Create_With_Validation_With_FBIService_mock() { //setup DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test2\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); FBIService fbiService = new FBIService(); Mock\u0026lt;IFBIService\u0026gt; fbiServiceMock = new Mock\u0026lt;IFBIService\u0026gt;(); fbiServiceMock.Setup(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())).Returns(Task.FromResult\u0026lt;bool\u0026gt;(true)); AccountControllerV4 controller = new AccountControllerV4(context, fbiService); //act IActionResult result = await controller.Create(new Account() { Id = 1, Name = \u0026quot;Checking\u0026quot;, SSN = \u0026quot;000-05-1120\u0026quot; }); Assert.True(result != null); // the result isn't null Assert.True(context.Accounts.Count() == 1); // the result has the count we expect Assert.True(context.Accounts.First().Id == 1); // the record has the id we expect Assert.True(context.Accounts.First().Name == \u0026quot;Checking\u0026quot;); // it has the right name Assert.True(context.Accounts.First().DateCreated != null); // we saved a date Assert.True(context.Accounts.First().SSN == \u0026quot;000-05-1120\u0026quot;); // test that creating a blank name returns a 422 code IActionResult result2 = await controller.Create(new Account() { Id = 1, Name = \u0026quot;\u0026quot;, SSN = \u0026quot;000-05-1120\u0026quot; }); Assert.True((result2 as StatusCodeResult).StatusCode == 422); // test that creating duplicate names returns 422 IActionResult resultUnique = await controller.Create(new Account() { Id = 2, Name = \u0026quot;Checking1\u0026quot;, SSN = \u0026quot;000-05-1120\u0026quot; }); IActionResult resultUniqueTest = await controller.Create(new Account() { Id = 3, Name = \u0026quot;Checking1\u0026quot;, SSN = \u0026quot;000-05-1120\u0026quot; }); Assert.True((result2 as StatusCodeResult).StatusCode == 422); // we're now able to test that if the fbi service returns false we handle it with a 400 response Mock\u0026lt;IFBIService\u0026gt; fbiServiceMock2 = new Mock\u0026lt;IFBIService\u0026gt;(); fbiServiceMock2.Setup(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())).Returns(Task.FromResult\u0026lt;bool\u0026gt;(false)); AccountControllerV4 controller2 = new AccountControllerV4(context, fbiServiceMock2.Object); IActionResult result3 = await controller2.Create(new Account() { Id = 4, Name = \u0026quot;CheckingNew\u0026quot;, SSN = \u0026quot;000-05-1120\u0026quot; }); Assert.True((result3 as StatusCodeResult).StatusCode == 400); }  In this iteration we changed the FBI service to use an interface and be injected into the controller. This will allow us to test the FBI service in isolation and it will allow us to mock the service in our controller. Our methods continue to grow. How can we improve this? Our controller is doing a lot of stuff. How could we move this application to a service bus? That would be difficult because our app is deeply coupled to ASP.NET. Our validation is still in our controller method and should be in it\u0026rsquo;s own class.\nIteration 5 This one is a major refactor. We\u0026rsquo;re going to break everything into SOLID pieces and add a repository layer over the Entity Framework context. This will let us mock our data access layer without needing to use Entity Framework. We\u0026rsquo;re moving validation to it\u0026rsquo;s own set of classes and we\u0026rsquo;re injecting everything.\n public class AccountControllerV5 : ControllerBase { private IAccountRepositoryV5 repository; private IFBIServiceV5 fbiService; private IAccountModelValiatorV5 modelValidator; public AccountControllerV5(IAccountRepositoryV5 repository, IAccountModelValiatorV5 modelValidator, IFBIServiceV5 fbiService) { this.repository = repository; this.fbiService = fbiService; this.modelValidator = modelValidator; } [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Create(Account account) { ValidationResultV5 result = this.modelValidator.Validate(account); if (result.Success) { if (!await this.fbiService.VerifyWithFBI(account.SSN)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.BadRequest); } this.repository.Create(account); return this.Ok(account); } else { return this.StatusCode(422, result); } } } #region validation public class ValidationResultV5 { public bool Success { get; private set; } = true; public string Message { get; private set; } = \u0026quot;\u0026quot;; public ValidationResultV5(bool success, string message) { this.Success = success; this.Message = message; } public ValidationResultV5() { } } public interface IAccountModelValiatorV5 { ValidationResultV5 Validate(Account account); } public class AccountModelValiatorV5 { private IAccountRepositoryV5 repository; public AccountModelValiatorV5(IAccountRepositoryV5 repository) { this.repository = repository; } public ValidationResultV5 Validate(Account account) { if (string.IsNullOrWhiteSpace(account.Name)) { return new ValidationResultV5(false, \u0026quot;Account name cannot be empty\u0026quot;); } if (this.repository.Exists(account.Name)) { return new ValidationResultV5(false, \u0026quot;Account name already exists\u0026quot;); } if (string.IsNullOrWhiteSpace(account.SSN)) { return new ValidationResultV5(false, \u0026quot;Customer id cannot be empty\u0026quot;); } return new ValidationResultV5(); } } #endregion #region repository public interface IAccountRepositoryV5 { bool Exists(string name); void Create(Account account); } public class AccountRepositoryV5 : IAccountRepositoryV5 { private ApplicationDbContext context; public AccountRepositoryV5(ApplicationDbContext context) { this.context = context; } public bool Exists(string name) { return this.context.Accounts.Any(x =\u0026gt; x.Name == name); } public void Create(Account account) { this.context.Accounts.Add(account); context.SaveChanges(); } } #endregion #region fbiService public interface IFBIServiceV5 { Task\u0026lt;bool\u0026gt; VerifyWithFBI(string ssn); } public class FBIServiceV5 : IFBIServiceV5 { public FBIServiceV5() { } /// \u0026lt;summary\u0026gt; /// This can only be tested in an integration test. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;ssn\u0026quot;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public async Task\u0026lt;bool\u0026gt; VerifyWithFBI(string ssn) { var client = new HttpClient(); string response = await client.GetStringAsync(\u0026quot;https://jsonplaceholder.typicode.com/posts/1\u0026quot;); if (!string.IsNullOrWhiteSpace(response)) { return true; } else { return false; } } }  [Fact] public async void Test_Account_Create_Happy_Path() { //setup Mock\u0026lt;IAccountRepositoryV5\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV5\u0026gt;(); Mock\u0026lt;IAccountModelValiatorV5\u0026gt; modelValidatorMock = new Mock\u0026lt;IAccountModelValiatorV5\u0026gt;(); Mock\u0026lt;IFBIServiceV5\u0026gt; fbiServiceMock = new Mock\u0026lt;IFBIServiceV5\u0026gt;(); // all of our mocks are returning what they should for a successful request fbiServiceMock.Setup(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())).Returns(Task.FromResult\u0026lt;bool\u0026gt;(true)); modelValidatorMock.Setup(x =\u0026gt; x.Validate(It.IsAny\u0026lt;Account\u0026gt;())).Returns(new ValidationResultV5()); //act AccountControllerV5 controller = new AccountControllerV5(repositoryMock.Object, modelValidatorMock.Object, fbiServiceMock.Object); IActionResult result = await controller.Create(new Account()); //verify Assert.True((result as OkObjectResult).StatusCode == 200); // ok result modelValidatorMock.Verify(x =\u0026gt; x.Validate(It.IsAny\u0026lt;Account\u0026gt;())); // verify the methods on our objects are actually called fbiServiceMock.Verify(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())); } [Fact] public async void Test_Account_Create_Validation_Failed() { //setup Mock\u0026lt;IAccountRepositoryV5\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV5\u0026gt;(); Mock\u0026lt;IAccountModelValiatorV5\u0026gt; modelValidatorMock = new Mock\u0026lt;IAccountModelValiatorV5\u0026gt;(); Mock\u0026lt;IFBIServiceV5\u0026gt; fbiServiceMock = new Mock\u0026lt;IFBIServiceV5\u0026gt;(); // all of our mocks are returning what they should for a successful request fbiServiceMock.Setup(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())).Returns(Task.FromResult\u0026lt;bool\u0026gt;(true)); repositoryMock.Setup(x =\u0026gt; x.Create(It.IsAny\u0026lt;Account\u0026gt;())); modelValidatorMock.Setup(x =\u0026gt; x.Validate(It.IsAny\u0026lt;Account\u0026gt;())).Returns(new ValidationResultV5(false, \u0026quot;error\u0026quot;)); //act AccountControllerV5 controller = new AccountControllerV5(repositoryMock.Object, modelValidatorMock.Object, fbiServiceMock.Object); IActionResult result = await controller.Create(new Account()); //verify Assert.True((result as ObjectResult).StatusCode == 422); } [Fact] public async void Test_Account_Create_FBIService_Failed() { //setup Mock\u0026lt;IAccountRepositoryV5\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV5\u0026gt;(); Mock\u0026lt;IAccountModelValiatorV5\u0026gt; modelValidatorMock = new Mock\u0026lt;IAccountModelValiatorV5\u0026gt;(); Mock\u0026lt;IFBIServiceV5\u0026gt; fbiServiceMock = new Mock\u0026lt;IFBIServiceV5\u0026gt;(); // all of our mocks are returning what they should for a successful request fbiServiceMock.Setup(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())).Returns(Task.FromResult\u0026lt;bool\u0026gt;(false)); repositoryMock.Setup(x =\u0026gt; x.Create(It.IsAny\u0026lt;Account\u0026gt;())); modelValidatorMock.Setup(x =\u0026gt; x.Validate(It.IsAny\u0026lt;Account\u0026gt;())).Returns(new ValidationResultV5()); //act AccountControllerV5 controller = new AccountControllerV5(repositoryMock.Object, modelValidatorMock.Object, fbiServiceMock.Object); IActionResult result = await controller.Create(new Account()); //verify Assert.True((result as StatusCodeResult).StatusCode == 400); } [Fact] public void Test_Account_Model_Validator_Empty_Account_Name() { Mock\u0026lt;IAccountRepositoryV5\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV5\u0026gt;(); AccountModelValiatorV5 valiator = new AccountModelValiatorV5(repositoryMock.Object); Account account = new Account(); account.DateCreated = DateTime.Now; account.SSN = \u0026quot;000-05-1120\u0026quot;; account.Name = string.Empty; ValidationResultV5 result = valiator.Validate(account); Assert.False(result.Success); Assert.Equal(\u0026quot;Account name cannot be empty\u0026quot;, result.Message); } [Fact] public void Test_Account_Model_Validator_Valid_Account_Name() { Mock\u0026lt;IAccountRepositoryV5\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV5\u0026gt;(); AccountModelValiatorV5 valiator = new AccountModelValiatorV5(repositoryMock.Object); Account account = new Account(); account.DateCreated = DateTime.Now; account.SSN = \u0026quot;000-05-1120\u0026quot;; account.Name = \u0026quot;Test\u0026quot;; ValidationResultV5 result = valiator.Validate(account); Assert.True(result.Success); Assert.True(result.Message == string.Empty); } [Fact] public void Test_Account_Model_Validator_Empty_SSN() { Mock\u0026lt;IAccountRepositoryV5\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV5\u0026gt;(); AccountModelValiatorV5 valiator = new AccountModelValiatorV5(repositoryMock.Object); Account account = new Account(); account.DateCreated = DateTime.Now; account.SSN = default(string); account.Name = \u0026quot;test\u0026quot;; ValidationResultV5 result = valiator.Validate(account); Assert.False(result.Success); Assert.Equal(\u0026quot;Customer id cannot be empty\u0026quot;, result.Message); } [Fact] public void Test_Account_Model_Validator_Valid_SSN() { Mock\u0026lt;IAccountRepositoryV5\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV5\u0026gt;(); AccountModelValiatorV5 valiator = new AccountModelValiatorV5(repositoryMock.Object); Account account = new Account(); account.DateCreated = DateTime.Now; account.SSN = \u0026quot;000-05-1120\u0026quot;; account.Name = \u0026quot;test\u0026quot;; ValidationResultV5 result = valiator.Validate(account); Assert.True(result.Success); Assert.Equal(string.Empty, result.Message); } [Fact] public void Test_Account_Model_Validator_Account_Exists() { Mock\u0026lt;IAccountRepositoryV5\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV5\u0026gt;(); repositoryMock.Setup(x =\u0026gt; x.Exists(It.IsAny\u0026lt;string\u0026gt;())).Returns(true); AccountModelValiatorV5 valiator = new AccountModelValiatorV5(repositoryMock.Object); Account account = new Account(); account.DateCreated = DateTime.Now; account.SSN = \u0026quot;000-05-1120\u0026quot;; account.Name = \u0026quot;test\u0026quot;; ValidationResultV5 result = valiator.Validate(account); Assert.False(result.Success); Assert.Equal(\u0026quot;Account name already exists\u0026quot;, result.Message); } [Fact] public void Test_Account_Model_Validator_Account_Not_Exists() { Mock\u0026lt;IAccountRepositoryV5\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV5\u0026gt;(); repositoryMock.Setup(x =\u0026gt; x.Exists(It.IsAny\u0026lt;string\u0026gt;())).Returns(false); AccountModelValiatorV5 valiator = new AccountModelValiatorV5(repositoryMock.Object); Account account = new Account(); account.DateCreated = DateTime.Now; account.SSN = \u0026quot;000-05-1120\u0026quot;; account.Name = \u0026quot;test\u0026quot;; ValidationResultV5 result = valiator.Validate(account); Assert.True(result.Success); Assert.Equal(string.Empty, result.Message); } [Fact] public void Test_Account_Repository_Create() { DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test1\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); IAccountRepositoryV5 repository = new AccountRepositoryV5(context); repository.Create(new Account()); Assert.True(context.Accounts.Count() == 1); } [Fact] public void Test_Account_Repository_Exists_Record_Exists() { DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test1\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); IAccountRepositoryV5 repository = new AccountRepositoryV5(context); var account = new Account(); account.Name = \u0026quot;testing\u0026quot;; context.Accounts.Add(account); context.SaveChanges(); bool exists = repository.Exists(\u0026quot;testing\u0026quot;); Assert.True(exists); } [Fact] public void Test_Account_Repository_Exists_Record_Not_Exists() { DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test1\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); IAccountRepositoryV5 repository = new AccountRepositoryV5(context); bool exists = repository.Exists(\u0026quot;testing\u0026quot;); Assert.False(exists); }  That\u0026rsquo;s a lot of change. Our validators, repository and FBI service are now in their own classes and are injected into our controller. This is looking better! We\u0026rsquo;ve added lots of unit tests that actually test a unit. I won\u0026rsquo;t go into detail on what these tests do. They should be self explanatory which is how unit tests are supposed to be. The test name should clue you in on what is being tested. The tests should be less than 10 lines long in most cases so there isn\u0026rsquo;t this enormous overhead to understand what a test does and changing tests should be easier that our first tests we wrote that were testing everything. Our repository tests are technically integration tests but that\u0026rsquo;s ok there isn\u0026rsquo;t any other way to test it.\nIteration 6 Requirement change There has been a requirement change and we need to receive a token from the client web service when accounts are created but we can\u0026rsquo;t return the token in any account responses because it should be private.\nWe also need to add a Get method to retrieve an account by id.\nWe need to accept a token in the request but not return it in the response.\nThere are no changes in this iteration\u0026rsquo;s code. Look at it and think about how you would make the request and response differ.\n public class AccountControllerV6 : ControllerBase { private IAccountRepositoryV6 repository; private IFBIServiceV6 fbiService; private IAccountModelValiatorV6 modelValidator; public AccountControllerV6(IAccountRepositoryV6 repository, IAccountModelValiatorV6 modelValidator, IFBIServiceV6 fbiService) { this.repository = repository; this.fbiService = fbiService; this.modelValidator = modelValidator; } [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Create(Account account) { ValidationResultV6 result = this.modelValidator.Validate(account); if (result.Success) { if (!await this.fbiService.VerifyWithFBI(account.SSN)) { return new StatusCodeResult((int)System.Net.HttpStatusCode.BadRequest); } this.repository.Create(account); return this.Ok(account); } else { return this.StatusCode(422, result); } } [HttpGet] public IActionResult Get(int id) { Account record = this.repository.Find(id); if (record == null) { return this.StatusCode(404); } else { return this.Ok(record); } } } #region validation public class ValidationResultV6 { public bool Success { get; private set; } = true; public string Message { get; private set; } = \u0026quot;\u0026quot;; public ValidationResultV6(bool success, string message) { this.Success = success; this.Message = message; } public ValidationResultV6() { } } public interface IAccountModelValiatorV6 { ValidationResultV6 Validate(Account account); } public class AccountModelValiatorV6 { private IAccountRepositoryV6 repository; public AccountModelValiatorV6(IAccountRepositoryV6 repository) { this.repository = repository; } public ValidationResultV6 Validate(Account account) { if (string.IsNullOrWhiteSpace(account.Name)) { return new ValidationResultV6(false, \u0026quot;Account name cannot be empty\u0026quot;); } if (this.repository.Exists(account.Name)) { return new ValidationResultV6(false, \u0026quot;Account name already exists\u0026quot;); } if (string.IsNullOrWhiteSpace(account.SSN)) { return new ValidationResultV6(false, \u0026quot;Customer id cannot be empty\u0026quot;); } return new ValidationResultV6(); } } #endregion #region repository public interface IAccountRepositoryV6 { bool Exists(string name); void Create(Account account); Account Find(int id); } public class AccountRepositoryV6 : IAccountRepositoryV6 { private ApplicationDbContext context; public AccountRepositoryV6(ApplicationDbContext context) { this.context = context; } public bool Exists(string name) { return this.context.Accounts.Any(x =\u0026gt; x.Name == name); } public void Create(Account account) { this.context.Accounts.Add(account); context.SaveChanges(); } public Account Find(int id) { return this.context.Accounts.FirstOrDefault(x =\u0026gt; x.Id == id); } } #endregion #region fbiService public interface IFBIServiceV6 { Task\u0026lt;bool\u0026gt; VerifyWithFBI(string ssn); } public class FBIServiceV6 : IFBIServiceV6 { HttpClient client; public FBIServiceV6(HttpClient client) { this.client = client; } public async Task\u0026lt;bool\u0026gt; VerifyWithFBI(string ssn) { string response = await this.client.GetStringAsync(\u0026quot;https://jsonplaceholder.typicode.com/posts/1\u0026quot;); if (!string.IsNullOrWhiteSpace(response)) { return true; } else { return false; } } }  There isn\u0026rsquo;t a test project for this iteration because I wanted to demonstrate the changing requirements. V7 will fix the issues and test them. We\u0026rsquo;ve added our method to allow retrieving the account but we\u0026rsquo;re exposing the secret token we\u0026rsquo;re not supposed to(this is in Account.cs). Our response and request model have diverged! What do we do? You may have realized by now that using your database entity as your request model is not a good idea. We\u0026rsquo;ve discovered that when the model diverges you\u0026rsquo;re in a pickle. You can hack it to make it work which means having extra fields or you split your model into a request and a response.\nAnother thing to think about now is how would we dump ASP.NET and move our system to a service bus? The validation and the FBI service is still in the controller. Would the service bus have to call the controller in code? Our system is still too coupled. You should be able to replace the controller layer with a winform app or a service bus and there should be no issues there. The root problem is there is still too much happening in our controller. We changed the FBI service in this iteration to accept the HttpClient as a parameter. This would let us inject it and test this service later.\nIteration 7 Create separate request and response models so we can satisfy our requirements that a token is in the request but not in the response.\npublic class AccountControllerV7 : ControllerBase { AccountServiceV7 service; public AccountControllerV7(AccountServiceV7 service) { this.service = service; } [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Create(AccountRequestModelV7 model) { ActionResultV7 result = await this.service.Create(model); if(result.Success) { return this.Ok(result.Object); } else { return this.StatusCode(400); } } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get (int id) { ActionResultV7 result = await this.service.Get(id); if (result.Success) { return this.Ok(result.Object); } else { return this.StatusCode(404); } } } #region models public class AccountRequestModelV7 { public int Id { get; set; } // internal record identifier for this account public string Name { get; set; } // checking, saving, investment public string SSN { get; set; } // a unique customer id used to globally track a person's bank accounts public DateTime DateCreated { get; set; } // when the account was created public string Token { get; set; } // secret token. We never want to expose this. } public class AccountResponseModelV7 { public int Id { get; set; } // internal record identifier for this account public string Name { get; set; } // checking, saving, investment public string SSN { get; set; } // a unique customer id used to globally track a person's bank accounts public DateTime DateCreated { get; set; } // when the account was created } #endregion #region service public class ActionResultV7 { public bool Success { get; private set; } public object Object { get; private set; } public ActionResultV7(bool success, object @object) { this.Success = success; this.Object = @object; } public ActionResultV7(ValidationResultV7 result) { this.Success = result.Success; this.Object = result.Message; } } public class AccountServiceV7 { private IAccountRepositoryV7 repository; private IFBIServiceV7 fbiService; private IAccountModelValiatorV7 modelValidator; public AccountServiceV7(IAccountRepositoryV7 repository, IAccountModelValiatorV7 modelValidator, IFBIServiceV7 fbiService) { this.repository = repository; this.fbiService = fbiService; this.modelValidator = modelValidator; } public async Task\u0026lt;ActionResultV7\u0026gt; Create(AccountRequestModelV7 model) { ValidationResultV7 result = this.modelValidator.Validate(model); if (result.Success) { if (!await this.fbiService.VerifyWithFBI(model.SSN)) { return new ActionResultV7(false, new ValidationResultV7(false, \u0026quot;Unable to validate with FBI\u0026quot;)); } var account = new Account(0, model.Name, model.SSN, DateTime.Now, model.Token); this.repository.Create(account); return new ActionResultV7(true, account); } else { return new ActionResultV7(result); } } public async Task\u0026lt;ActionResultV7\u0026gt; Get(int id) { Account record = await this.repository.Find(id); if(record == null) { return new ActionResultV7(false, new ValidationResultV7(false, \u0026quot;Record not found\u0026quot;)); } else { var response = new AccountResponseModelV7() { DateCreated = record.DateCreated, SSN = record.SSN, Id = record.Id, Name = record.Name }; return new ActionResultV7(true, response); } } } #endregion #region validation public class ValidationResultV7 { public bool Success { get; private set; } = true; public string Message { get; private set; } = \u0026quot;\u0026quot;; public ValidationResultV7(bool success, string message) { this.Success = success; this.Message = message; } public ValidationResultV7() { } } public interface IAccountModelValiatorV7 { ValidationResultV7 Validate(AccountRequestModelV7 account); } public class AccountModelValiatorV7 { private IAccountRepositoryV7 repository; public AccountModelValiatorV7(IAccountRepositoryV7 repository) { this.repository = repository; } public ValidationResultV7 Validate(Account account) { if (string.IsNullOrWhiteSpace(account.Name)) { return new ValidationResultV7(false, \u0026quot;Account name cannot be empty\u0026quot;); } if (this.repository.Exists(account.Name)) { return new ValidationResultV7(false, \u0026quot;Account name already exists\u0026quot;); } if (string.IsNullOrWhiteSpace(account.SSN)) { return new ValidationResultV7(false, \u0026quot;Customer id cannot be empty\u0026quot;); } return new ValidationResultV7(); } } #endregion #region repository public interface IAccountRepositoryV7 { bool Exists(string name); void Create(Account account); Task\u0026lt;Account\u0026gt; Find(int id); } public class AccountRepositoryV7 : IAccountRepositoryV7 { private ApplicationDbContext context; public AccountRepositoryV7(ApplicationDbContext context) { this.context = context; } public bool Exists(string name) { return this.context.Accounts.Any(x =\u0026gt; x.Name == name); } public void Create(Account account) { this.context.Accounts.Add(account); context.SaveChanges(); } public async Task\u0026lt;Account\u0026gt; Find(int id) { return await this.context.Accounts.FirstOrDefaultAsync(x =\u0026gt; x.Id == id); } } #endregion #region fbiService public interface IFBIServiceV7 { Task\u0026lt;bool\u0026gt; VerifyWithFBI(string ssn); } public class FBIServiceV7 : IFBIServiceV7 { HttpClient client; public FBIServiceV7(HttpClient client) { this.client = client; } public async Task\u0026lt;bool\u0026gt; VerifyWithFBI(string ssn) { string response = await this.client.GetStringAsync(\u0026quot;https://jsonplaceholder.typicode.com/posts/1\u0026quot;); if (!string.IsNullOrWhiteSpace(response)) { return true; } else { return false; } } }  In this iteration we added AccountRequestModelV7 and AccountResponseModelV7 and we created another layer which is the service layer. By creating this service layer we can put all of the business logic like calling the FBI service and validating entities in this layer instead of the controller. This will allow us to move to a service bus later which we couldn\u0026rsquo;t do if the validation was done in the controller. Notice how \u0026ldquo;thin\u0026rdquo; the controller is. It does very little besides call the service.\n We\u0026rsquo;re still using inline object initialization. We still can\u0026rsquo;t test the dateCreated logic. We still can\u0026rsquo;t test individual field level validation our models without testing all of the validation.  Iteration 8 We\u0026rsquo;re going to introduce Fluent Validation in this iteration. Fluent Validation will let us test individual validators on fields.\nWe\u0026rsquo;re going to move object mapping to it\u0026rsquo;s own class so we only have to update that logic in once place.\nWe\u0026rsquo;re going to create a date service to facilitate testing. This interface would let us introduce NodaTime or other date libraries to help with time zone issues.\npublic class AccountControllerV8 : ControllerBase { AccountServiceV8 service; public AccountControllerV8(AccountServiceV8 service) { this.service = service; } [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Create(AccountRequestModelV8 model) { ActionResultV8 result = await this.service.Create(model); if (result.Success) { return this.Ok(result.Object); } else { return this.StatusCode(400); } } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get(int id) { ActionResultV8 result = await this.service.Get(id); if (result.Success) { return this.Ok(result.Object); } else { return this.StatusCode(404); } } } #endregion #region models public class AccountRequestModelV8 { public int Id { get; set; } // internal record identifier for this account public string Name { get; set; } // checking, saving, investment public string SSN { get; set; } // a unique customer id used to globally track a person's bank accounts public DateTime DateCreated { get; set; } // when the account was created public string Token { get; set; } // secret token. We never want to expose this. public AccountRequestModelV8() { } public AccountRequestModelV8(int id, string name, string ssn, DateTime dateCreated, string token) { this.Id = id; this.Name = name; this.SSN = ssn; this.DateCreated = dateCreated; this.Token = token; } } public class AccountResponseModelV8 { public int Id { get; set; } // internal record identifier for this account public string Name { get; set; } // checking, saving, investment public string SSN { get; set; } // a unique customer id used to globally track a person's bank accounts public DateTime DateCreated { get; set; } // when the account was created public AccountResponseModelV8(int id, string name, string ssn, DateTime dateCreated) { this.Id = id; this.Name = name; this.SSN = ssn; this.DateCreated = dateCreated; } } #endregion #region service public class ActionResultV8 { public bool Success { get; private set; } public object Object { get; private set; } public ActionResultV8(bool success, object @object) { this.Success = success; this.Object = @object; } public ActionResultV8(ValidationResultV8 result) { this.Success = result.Success; this.Object = result.Message; } public ActionResultV8(ValidationResult result) { this.Success = result.IsValid; this.Object = result.Errors.FirstOrDefault()?.ErrorMessage; } } public class AccountServiceV8 { private IAccountRepositoryV8 repository; private IFBIServiceV8 fbiService; private AccountRequestModelValidatorV8 modelValidator; private IDateServiceV8 dateService; private IAccountMapperV8 mapper; public AccountServiceV8(IAccountRepositoryV8 repository, AccountRequestModelValidatorV8 modelValidator, IFBIServiceV8 fbiService, IDateServiceV8 dateService, IAccountMapperV8 mapper) { this.repository = repository; this.fbiService = fbiService; this.modelValidator = modelValidator; this.dateService = dateService; this.mapper = mapper; } public async Task\u0026lt;ActionResultV8\u0026gt; Create(AccountRequestModelV8 model) { ValidationResult result = this.modelValidator.Validate(model); if (result.IsValid) { if (!await this.fbiService.VerifyWithFBI(model.SSN)) { return new ActionResultV8(false, new ValidationResultV8(false, \u0026quot;Unable to validate with FBI\u0026quot;)); } Account account = this.mapper.MapRequestToEntity(model); this.repository.Create(account); return new ActionResultV8(true, account); } else { return new ActionResultV8(result); } } public async Task\u0026lt;ActionResultV8\u0026gt; Get(int id) { Account record = await this.repository.Find(id); if (record == null) { return new ActionResultV8(false, new ValidationResultV8(false, \u0026quot;Record not found\u0026quot;)); } else { AccountResponseModelV8 response = this.mapper.MapEntityToResponse(record); return new ActionResultV8(true, response); } } } #endregion #region mapper public interface IAccountMapperV8 { Account MapRequestToEntity(AccountRequestModelV8 model); AccountResponseModelV8 MapEntityToResponse(Account entity); } /// \u0026lt;summary\u0026gt; /// You could also use AutoMapper here. I prefer just using constructors or methods to set the properties. /// /// \u0026lt;/summary\u0026gt; public class AccountMapperV8 : IAccountMapperV8 { public Account MapRequestToEntity(AccountRequestModelV8 model) { return new Account(model.Id, model.Name, model.SSN, model.DateCreated, model.Token); } public AccountResponseModelV8 MapEntityToResponse(Account entity) { return new AccountResponseModelV8(entity.Id,entity.Name, entity.SSN, entity.DateCreated); } } #endregion #region validation public class AccountRequestModelValidatorV8 : AbstractValidator\u0026lt;AccountRequestModelV8\u0026gt; { IAccountRepositoryV8 repository; public AccountRequestModelValidatorV8(IAccountRepositoryV8 repository) { this.repository = repository; this.RuleFor(x =\u0026gt; x.Name).NotEmpty(); this.RuleFor(x =\u0026gt; x.SSN).NotEmpty(); this.RuleFor(x =\u0026gt; x.Token).NotEmpty(); this.RuleFor(x =\u0026gt; x.Name).Must(this.AccountValidated).WithMessage(\u0026quot;Account already exists\u0026quot;); } private bool AccountValidated(string name) { return !this.repository.Exists(name); } } public class ValidationResultV8 { public bool Success { get; private set; } = true; public string Message { get; private set; } = \u0026quot;\u0026quot;; public ValidationResultV8(bool success, string message) { this.Success = success; this.Message = message; } public ValidationResultV8() { } } #endregion #region repository public interface IAccountRepositoryV8 { bool Exists(string name); void Create(Account account); Task\u0026lt;Account\u0026gt; Find(int id); } public class AccountRepositoryV8 : IAccountRepositoryV8 { private ApplicationDbContext context; public AccountRepositoryV8(ApplicationDbContext context) { this.context = context; } public bool Exists(string name) { return this.context.Accounts.Any(x =\u0026gt; x.Name == name); } public void Create(Account account) { this.context.Accounts.Add(account); context.SaveChanges(); } public async Task\u0026lt;Account\u0026gt; Find(int id) { return await this.context.Accounts.FirstOrDefaultAsync(x =\u0026gt; x.Id == id); } } #endregion #region fbiService public interface IFBIServiceV8 { Task\u0026lt;bool\u0026gt; VerifyWithFBI(string ssn); } public class FBIServiceV8 : IFBIServiceV8 { HttpClient client; public FBIServiceV8(HttpClient client) { this.client = client; } public async Task\u0026lt;bool\u0026gt; VerifyWithFBI(string ssn) { string response = await this.client.GetStringAsync(\u0026quot;https://jsonplaceholder.typicode.com/posts/1\u0026quot;); if (!string.IsNullOrWhiteSpace(response)) { return true; } else { return false; } } } #endregion #region dateService public interface IDateServiceV8 { DateTime Now(); } public class DateServiceV8 : IDateServiceV8 { public DateTime Now() { return DateTime.Now; } }  Final Iteration This iteration is just testing what was in iteration 8.\nWe\u0026rsquo;re introducing Fluent Assertions which is a great testing library.\npublic class UnitTestAccountV9Controller { [Fact] public async void Test_Account_Create_200() { //setup Mock\u0026lt;IAccountServiceV9\u0026gt; serviceMock = new Mock\u0026lt;IAccountServiceV9\u0026gt;(); serviceMock.Setup(x =\u0026gt; x.Create(It.IsAny\u0026lt;AccountRequestModelV9\u0026gt;())).Returns(Task.FromResult(new ActionResultV9(true, default(object)))); AccountV9Controller controller = new AccountV9Controller(serviceMock.Object); //act IActionResult result = await controller.Create(new AccountRequestModelV9()); //verify result.Should().BeOfType\u0026lt;OkObjectResult\u0026gt;(); (result as ObjectResult).StatusCode.Should().Be(200); serviceMock.Verify(x =\u0026gt; x.Create(It.IsAny\u0026lt;AccountRequestModelV9\u0026gt;())); } [Fact] public async void Test_Account_Create_422() { //setup Mock\u0026lt;IAccountServiceV9\u0026gt; serviceMock = new Mock\u0026lt;IAccountServiceV9\u0026gt;(); serviceMock.Setup(x =\u0026gt; x.Create(It.IsAny\u0026lt;AccountRequestModelV9\u0026gt;())).Returns(Task.FromResult(new ActionResultV9(false, default(object)))); AccountV9Controller controller = new AccountV9Controller(serviceMock.Object); //act IActionResult result = await controller.Create(new AccountRequestModelV9()); //verify result.Should().BeOfType\u0026lt;StatusCodeResult\u0026gt;(); (result as StatusCodeResult).StatusCode.Should().Be(422); serviceMock.Verify(x =\u0026gt; x.Create(It.IsAny\u0026lt;AccountRequestModelV9\u0026gt;())); } [Fact] public async void Test_Account_Get_200() { //setup Mock\u0026lt;IAccountServiceV9\u0026gt; serviceMock = new Mock\u0026lt;IAccountServiceV9\u0026gt;(); AccountV9Controller controller = new AccountV9Controller(serviceMock.Object); serviceMock.Setup(x =\u0026gt; x.Get(It.IsAny\u0026lt;int\u0026gt;())).Returns(Task.FromResult(new ActionResultV9(true, new AccountResponseModelV9()))); //act IActionResult result = await controller.Get(default(int)); //verify result.Should().BeOfType\u0026lt;OkObjectResult\u0026gt;(); (result as OkObjectResult).StatusCode.Should().Be(200); (result as OkObjectResult).Value.Should().NotBeNull(); serviceMock.Verify(x =\u0026gt; x.Get(It.IsAny\u0026lt;int\u0026gt;())); } [Fact] public async void Test_Account_Get_404() { //setup Mock\u0026lt;IAccountServiceV9\u0026gt; serviceMock = new Mock\u0026lt;IAccountServiceV9\u0026gt;(); AccountV9Controller controller = new AccountV9Controller(serviceMock.Object); serviceMock.Setup(x =\u0026gt; x.Get(It.IsAny\u0026lt;int\u0026gt;())).Returns(Task.FromResult(new ActionResultV9(false, default(object)))); //act IActionResult result = await controller.Get(default(int)); //verify result.Should().BeOfType\u0026lt;StatusCodeResult\u0026gt;(); (result as StatusCodeResult).StatusCode.Should().Be(404); serviceMock.Verify(x =\u0026gt; x.Get(It.IsAny\u0026lt;int\u0026gt;())); } [Fact] public async void Test_AccountService_Create_Success() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repository = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); Mock\u0026lt;IAccountMapperV9\u0026gt; mapperMock = new Mock\u0026lt;IAccountMapperV9\u0026gt;(); Mock\u0026lt;IAccountModelValidator\u0026gt; modelValidatorMock = new Mock\u0026lt;IAccountModelValidator\u0026gt;(); Mock\u0026lt;IDateServiceV9\u0026gt; dateServiceMock = new Mock\u0026lt;IDateServiceV9\u0026gt;(); Mock\u0026lt;IFBIServiceV9\u0026gt; fbiServiceMock = new Mock\u0026lt;IFBIServiceV9\u0026gt;(); modelValidatorMock.Setup(x =\u0026gt; x.Validate(It.IsAny\u0026lt;AccountRequestModelV9\u0026gt;())).Returns(new FluentValidation.Results.ValidationResult()); fbiServiceMock.Setup(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())).Returns(Task.FromResult(true)); mapperMock.Setup(x =\u0026gt; x.MapEntityToResponse(It.IsAny\u0026lt;Account\u0026gt;())).Returns(new AccountResponseModelV9()); repository.Setup(x =\u0026gt; x.Create(It.IsAny\u0026lt;Account\u0026gt;())); IAccountServiceV9 service = new AccountServiceV9(repository.Object, modelValidatorMock.Object, fbiServiceMock.Object, dateServiceMock.Object, mapperMock.Object); //act ActionResultV9 result = await service.Create(new AccountRequestModelV9()); //verify result.Success.Should().BeTrue(); result.Object.Should().BeOfType\u0026lt;AccountResponseModelV9\u0026gt;(); modelValidatorMock.Verify(x =\u0026gt; x.Validate(It.IsAny\u0026lt;AccountRequestModelV9\u0026gt;())); mapperMock.Verify(x =\u0026gt; x.MapEntityToResponse(It.IsAny\u0026lt;Account\u0026gt;())); repository.Verify(x =\u0026gt; x.Create(It.IsAny\u0026lt;Account\u0026gt;())); fbiServiceMock.Verify(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())); dateServiceMock.Verify(x =\u0026gt; x.Now()); } [Fact] public async void Test_AccountService_Create_ValidationFailure() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repository = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); Mock\u0026lt;IAccountMapperV9\u0026gt; mapperMock = new Mock\u0026lt;IAccountMapperV9\u0026gt;(); Mock\u0026lt;IAccountModelValidator\u0026gt; modelValidatorMock = new Mock\u0026lt;IAccountModelValidator\u0026gt;(); Mock\u0026lt;IDateServiceV9\u0026gt; dateServiceMock = new Mock\u0026lt;IDateServiceV9\u0026gt;(); Mock\u0026lt;IFBIServiceV9\u0026gt; fbiServiceMock = new Mock\u0026lt;IFBIServiceV9\u0026gt;(); modelValidatorMock.Setup(x =\u0026gt; x.Validate(It.IsAny\u0026lt;AccountRequestModelV9\u0026gt;())).Returns(new ValidationResult(new List\u0026lt;ValidationFailure\u0026gt;() { new ValidationFailure(default(string), default(string)) })); fbiServiceMock.Setup(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())).Returns(Task.FromResult(true)); mapperMock.Setup(x =\u0026gt; x.MapEntityToResponse(It.IsAny\u0026lt;Account\u0026gt;())).Returns(new AccountResponseModelV9()); repository.Setup(x =\u0026gt; x.Create(It.IsAny\u0026lt;Account\u0026gt;())); IAccountServiceV9 service = new AccountServiceV9(repository.Object, modelValidatorMock.Object, fbiServiceMock.Object, dateServiceMock.Object, mapperMock.Object); //act ActionResultV9 result = await service.Create(new AccountRequestModelV9()); //verify result.Success.Should().BeFalse(); result.Object.Should().BeOfType\u0026lt;List\u0026lt;ValidationFailure\u0026gt;\u0026gt;(); modelValidatorMock.Verify(x =\u0026gt; x.Validate(It.IsAny\u0026lt;AccountRequestModelV9\u0026gt;())); } [Fact] public async void Test_AccountService_Create_FBIService_Failure() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repository = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); Mock\u0026lt;IAccountMapperV9\u0026gt; mapperMock = new Mock\u0026lt;IAccountMapperV9\u0026gt;(); Mock\u0026lt;IAccountModelValidator\u0026gt; modelValidatorMock = new Mock\u0026lt;IAccountModelValidator\u0026gt;(); Mock\u0026lt;IDateServiceV9\u0026gt; dateServiceMock = new Mock\u0026lt;IDateServiceV9\u0026gt;(); Mock\u0026lt;IFBIServiceV9\u0026gt; fbiServiceMock = new Mock\u0026lt;IFBIServiceV9\u0026gt;(); modelValidatorMock.Setup(x =\u0026gt; x.Validate(It.IsAny\u0026lt;AccountRequestModelV9\u0026gt;())).Returns(new FluentValidation.Results.ValidationResult()); fbiServiceMock.Setup(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())).Returns(Task.FromResult(false)); mapperMock.Setup(x =\u0026gt; x.MapEntityToResponse(It.IsAny\u0026lt;Account\u0026gt;())).Returns(new AccountResponseModelV9()); repository.Setup(x =\u0026gt; x.Create(It.IsAny\u0026lt;Account\u0026gt;())); IAccountServiceV9 service = new AccountServiceV9(repository.Object, modelValidatorMock.Object, fbiServiceMock.Object, dateServiceMock.Object, mapperMock.Object); //act ActionResultV9 result = await service.Create(new AccountRequestModelV9()); //verify result.Success.Should().BeFalse(); result.Object.Should().BeOfType\u0026lt;ValidationResultV9\u0026gt;(); fbiServiceMock.Verify(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())); } [Fact] public async void Test_AccountService_Get_Found() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repository = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); Mock\u0026lt;IAccountMapperV9\u0026gt; mapperMock = new Mock\u0026lt;IAccountMapperV9\u0026gt;(); Mock\u0026lt;IAccountModelValidator\u0026gt; modelValidatorMock = new Mock\u0026lt;IAccountModelValidator\u0026gt;(); Mock\u0026lt;IDateServiceV9\u0026gt; dateServiceMock = new Mock\u0026lt;IDateServiceV9\u0026gt;(); Mock\u0026lt;IFBIServiceV9\u0026gt; fbiServiceMock = new Mock\u0026lt;IFBIServiceV9\u0026gt;(); modelValidatorMock.Setup(x =\u0026gt; x.Validate(It.IsAny\u0026lt;AccountRequestModelV9\u0026gt;())).Returns(new ValidationResult()); fbiServiceMock.Setup(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())).Returns(Task.FromResult(true)); mapperMock.Setup(x =\u0026gt; x.MapEntityToResponse(It.IsAny\u0026lt;Account\u0026gt;())).Returns(new AccountResponseModelV9()); repository.Setup(x =\u0026gt; x.Find(It.IsAny\u0026lt;int\u0026gt;())).Returns(Task.FromResult\u0026lt;Account\u0026gt;(new Account())); IAccountServiceV9 service = new AccountServiceV9(repository.Object, modelValidatorMock.Object, fbiServiceMock.Object, dateServiceMock.Object, mapperMock.Object); //act ActionResultV9 result = await service.Get(default(int)); //verify result.Success.Should().BeTrue(); result.Object.Should().BeOfType\u0026lt;AccountResponseModelV9\u0026gt;(); mapperMock.Verify(x =\u0026gt; x.MapEntityToResponse(It.IsAny\u0026lt;Account\u0026gt;())); repository.Verify(x =\u0026gt; x.Find(It.IsAny\u0026lt;int\u0026gt;())); } [Fact] public async void Test_AccountService_Get_Not_Found() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repository = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); Mock\u0026lt;IAccountMapperV9\u0026gt; mapperMock = new Mock\u0026lt;IAccountMapperV9\u0026gt;(); Mock\u0026lt;IAccountModelValidator\u0026gt; modelValidatorMock = new Mock\u0026lt;IAccountModelValidator\u0026gt;(); Mock\u0026lt;IDateServiceV9\u0026gt; dateServiceMock = new Mock\u0026lt;IDateServiceV9\u0026gt;(); Mock\u0026lt;IFBIServiceV9\u0026gt; fbiServiceMock = new Mock\u0026lt;IFBIServiceV9\u0026gt;(); modelValidatorMock.Setup(x =\u0026gt; x.Validate(It.IsAny\u0026lt;AccountRequestModelV9\u0026gt;())).Returns(new ValidationResult()); fbiServiceMock.Setup(x =\u0026gt; x.VerifyWithFBI(It.IsAny\u0026lt;string\u0026gt;())).Returns(Task.FromResult(true)); mapperMock.Setup(x =\u0026gt; x.MapEntityToResponse(It.IsAny\u0026lt;Account\u0026gt;())).Returns(new AccountResponseModelV9()); repository.Setup(x =\u0026gt; x.Find(It.IsAny\u0026lt;int\u0026gt;())).Returns(Task.FromResult\u0026lt;Account\u0026gt;(null)); IAccountServiceV9 service = new AccountServiceV9(repository.Object, modelValidatorMock.Object, fbiServiceMock.Object, dateServiceMock.Object, mapperMock.Object); //act ActionResultV9 result = await service.Get(default(int)); //verify result.Success.Should().BeFalse(); repository.Verify(x =\u0026gt; x.Find(It.IsAny\u0026lt;int\u0026gt;())); } [Fact] public void Test_Mapper_MapRequestToEntity() { //setup IAccountMapperV9 mapper = new AccountMapperV9(); var request = new AccountRequestModelV9(1, \u0026quot;A\u0026quot;, \u0026quot;000-05-1120\u0026quot;, DateTime.Parse(\u0026quot;7/3/2018 4:41:42 PM\u0026quot;), \u0026quot;A\u0026quot;); //act Account entity = mapper.MapRequestToEntity(request); //verify entity.DateCreated.Should().Be(DateTime.Parse(\u0026quot;7/3/2018 4:41:42 PM\u0026quot;)); entity.Id.Should().Be(1); entity.Name.Should().Be(\u0026quot;A\u0026quot;); entity.SSN.Should().Be(\u0026quot;000-05-1120\u0026quot;); entity.Token.Should().Be(\u0026quot;A\u0026quot;); } [Fact] public void Test_Mapper_MapEntityToResponse() { //setup IAccountMapperV9 mapper = new AccountMapperV9(); var entity = new Account(1, \u0026quot;A\u0026quot;, \u0026quot;000-05-1120\u0026quot;, DateTime.Parse(\u0026quot;7 /3/2018 4:41:42 PM\u0026quot;), \u0026quot;A\u0026quot;); //act AccountResponseModelV9 response = mapper.MapEntityToResponse(entity); //verify response.DateCreated.Should().Be(DateTime.Parse(\u0026quot;7/3/2018 4:41:42 PM\u0026quot;)); response.Id.Should().Be(1); response.Name.Should().Be(\u0026quot;A\u0026quot;); response.SSN.Should().Be(\u0026quot;000-05-1120\u0026quot;); } [Fact] public void Test_ModelValidator_Name_NotEmpty_Valid() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); repositoryMock.Setup(x =\u0026gt; x.Exists(It.IsAny\u0026lt;string\u0026gt;())).Returns(false); AccountRequestModelValidatorV9 validator = new AccountRequestModelValidatorV9(repositoryMock.Object); //act and verify validator.ShouldNotHaveValidationErrorFor(x =\u0026gt; x.Name, \u0026quot;A\u0026quot;); } [Fact] public void Test_ModelValidator_Name_NotEmpty_Invalid() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); repositoryMock.Setup(x =\u0026gt; x.Exists(It.IsAny\u0026lt;string\u0026gt;())).Returns(false); AccountRequestModelValidatorV9 validator = new AccountRequestModelValidatorV9(repositoryMock.Object); //act and verify validator.ShouldHaveValidationErrorFor(x =\u0026gt; x.Name, \u0026quot;\u0026quot;); validator.ShouldHaveValidationErrorFor(x =\u0026gt; x.Name, null as string); } [Fact] public void Test_ModelValidator_NameUnique_Valid() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); repositoryMock.Setup(x =\u0026gt; x.Exists(It.IsAny\u0026lt;string\u0026gt;())).Returns(false); AccountRequestModelValidatorV9 validator = new AccountRequestModelValidatorV9(repositoryMock.Object); //act and verify validator.ShouldNotHaveValidationErrorFor(x =\u0026gt; x.Name, \u0026quot;A\u0026quot;); } [Fact] public void Test_ModelValidator_NameUnique_Invalid() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); repositoryMock.Setup(x =\u0026gt; x.Exists(It.IsAny\u0026lt;string\u0026gt;())).Returns(true); AccountRequestModelValidatorV9 validator = new AccountRequestModelValidatorV9(repositoryMock.Object); //act and verify validator.ShouldHaveValidationErrorFor(x =\u0026gt; x.Name, \u0026quot;A\u0026quot;); } [Fact] public void Test_ModelValidator_SSN_NotEmpty_Valid() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); repositoryMock.Setup(x =\u0026gt; x.Exists(It.IsAny\u0026lt;string\u0026gt;())).Returns(false); AccountRequestModelValidatorV9 validator = new AccountRequestModelValidatorV9(repositoryMock.Object); //act and verify validator.ShouldNotHaveValidationErrorFor(x =\u0026gt; x.SSN, \u0026quot;000-05-1120\u0026quot;); } [Fact] public void Test_ModelValidator_SSN_NotEmpty_Invalid() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); repositoryMock.Setup(x =\u0026gt; x.Exists(It.IsAny\u0026lt;string\u0026gt;())).Returns(false); AccountRequestModelValidatorV9 validator = new AccountRequestModelValidatorV9(repositoryMock.Object); //act and verify validator.ShouldHaveValidationErrorFor(x =\u0026gt; x.SSN, string.Empty); } [Fact] public void Test_ModelValidator_Token_NotEmpty_Valid() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); repositoryMock.Setup(x =\u0026gt; x.Exists(It.IsAny\u0026lt;string\u0026gt;())).Returns(false); AccountRequestModelValidatorV9 validator = new AccountRequestModelValidatorV9(repositoryMock.Object); //act and verify validator.ShouldNotHaveValidationErrorFor(x =\u0026gt; x.Token, \u0026quot;A\u0026quot;); } [Fact] public void Test_ModelValidator_Token_NotEmpty_Invalid() { //setup Mock\u0026lt;IAccountRepositoryV9\u0026gt; repositoryMock = new Mock\u0026lt;IAccountRepositoryV9\u0026gt;(); repositoryMock.Setup(x =\u0026gt; x.Exists(It.IsAny\u0026lt;string\u0026gt;())).Returns(false); AccountRequestModelValidatorV9 validator = new AccountRequestModelValidatorV9(repositoryMock.Object); //act and verify validator.ShouldHaveValidationErrorFor(x =\u0026gt; x.Token, \u0026quot;\u0026quot;); validator.ShouldHaveValidationErrorFor(x =\u0026gt; x.Token, null as string); } [Fact] public void Test_Account_Repository_Create() { //setup DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test1\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); IAccountRepositoryV9 repository = new AccountRepositoryV9(context); //act repository.Create(new Account()); //verify context.Accounts.Count().Should().Be(1); } [Fact] public void Test_Account_Repository_Exists_Record_Exists() { //setup DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test1\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); IAccountRepositoryV9 repository = new AccountRepositoryV9(context); context.Accounts.Add(new Account(default(int), \u0026quot;test\u0026quot;, default(string), default(DateTime), default(string))); context.SaveChanges(); //act bool exists = repository.Exists(\u0026quot;test\u0026quot;); //verify exists.Should().BeTrue(); } [Fact] public void Test_Account_Repository_Exists_Record_Not_Exists() { //setup DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test1\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); IAccountRepositoryV9 repository = new AccountRepositoryV9(context); //act bool exists = repository.Exists(\u0026quot;testing\u0026quot;); exists.Should().BeFalse(); } [Fact] public async void Test_Account_Repository_Find_Record_Exists() { //setup DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test1\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); IAccountRepositoryV9 repository = new AccountRepositoryV9(context); context.Accounts.Add(new Account(1, default(string), default(string), default(DateTime), default(string))); context.SaveChanges(); //act Account record = await repository.Find(1); //verify record.Should().NotBeNull(); } [Fact] public async void Test_Account_Repository_Find_Record_Not_Exists() { //setup DbContextOptionsBuilder optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseInMemoryDatabase(\u0026quot;test1\u0026quot;); var context = new ApplicationDbContext(optionsBuilder.Options); IAccountRepositoryV9 repository = new AccountRepositoryV9(context); //act Account record = await repository.Find(1); //verify record.Should().BeNull(); } [Fact] public void Test_DatetimeService() { //setup IDateServiceV9 service = new DateServiceV9(); DateTime now = DateTime.Now; //act DateTime result = service.Now(); //verify result.Should().BeCloseTo(now, 1000); } [Fact] public async void IntegrationTest_FBIService_Success() { //setup IFBIServiceV9 service = new FBIServiceV9(\u0026quot;https://jsonplaceholder.typicode.com/posts/1\u0026quot;); //act bool result = await service.VerifyWithFBI(default(string)); //verify result.Should().BeTrue(); } [Fact] public async void IntegrationTest_FBIService_Failure() { //setup IFBIServiceV9 service = new FBIServiceV9(\u0026quot;https://jsonplaceholder.typicode.com/posts/fail\u0026quot;); //act bool result = await service.VerifyWithFBI(default(string)); //verify result.Should().BeFalse(); }  We made lots of changes to really make our code testable. We introduced Fluent Validation to make testing easier for individual fields. We wrote all of our tests including an integration test for the FBI service\nThere is at least one big issue I still see with these tests. There is a lot of repetitive setup code. I would take the time to build factories to build your default mocks and make the code as DRY as possible.\nWe don\u0026rsquo;t have end to end tests. I\u0026rsquo;ll leave that for another article.\nSummary Use interfaces and dependency injection. Never directly depend on the database, file system, date libraries or network in your application. Unit tests should be deterministic and you can\u0026rsquo;t do that if you have these types of dependencies.\nOnly test the actual unit you should be testing not every little detail. Test should not overlap.\nWrite single responsibility code.\nWrite fast tests whenever possible.\nIf you don\u0026rsquo;t write SOLID code your project will not handle requirement changes and will turn into a ball of mud. By enforcing SOLID from the beginning of a project, even though it takes more code, it is significantly more likely that your project can evolve. Methods that do different things based on a parameter or setting should be two functions. Classes that handle different things should be split and the functionality combined with a facade or a mediator. \u0026ldquo;Different things\u0026rdquo; is subjective and it\u0026rsquo;s difficult to give you hard and fast rules. Generally if the code is difficult to work on and test and it\u0026rsquo;s not doing something hard then it should be refactored.\nThat\u0026rsquo;s the end. I hope you learned something that makes coding easier.\n"
},
{
	"uri": "/documentation/",
	"title": "Codenesium",
	"tags": [],
	"description": "",
	"content": " What is Codenesium? Codenesium is a mythical element that when applied to your software project allows your team to prototype and ship high quality software faster.\nHow does it work? Install the Codenesium application on your dev machine and load a schema from a database you already have. You can also use our handy database schema editing tool the Database Forge to create a schema. After that deploy your app and we take care of the REST.\nWe do several things\n Generate the source code for a ASP.NET Core REST API built on n-tier architecture with tests. Deploy your application to a playground server for testing. Download the source code to your machine ready to run. All you need is the .NET Core SDK installed. Detect when you have modified generated files and never step on them when you regenerate.  Why would I pay for this? Generating an API is nice but the long term value is being able to add fields and make changes to your database and regenerate. We fully expect most people to stop using the generation at some point and from then on make manual changes. That\u0026rsquo;s ok. You still have a well designed API that is still similar to the architecture you would have used anyway. What we\u0026rsquo;re offering is incredibly rapid prototyping on your API. You can focus on React or Angular or whatever front end technology is the flavor of the month while your API is ready to go. You can focus on business requirements instead of architecture and as the database rapidly changes as your requirements evolve you can simply regenerate the API. For many small projects you could ship what we generate and call it done.\nCode generation is bad though. It certainly can be. We\u0026rsquo;re not selling you a code generator. We\u0026rsquo;re selling you an application that an engineer could spend months writing. Ready to ship with tests. We\u0026rsquo;re always learning and applying feedback from other engineers to continuously improve what we\u0026rsquo;re generating. Iterating like that lets us save your team from a long list of roadblocks by combining the knowledge of the crowd into one architecture that is Codenesium.\nWhere can I see the code? The best place will be our samples page on github.\nWhere can I submit feedback? We are not experts and don\u0026rsquo;t claim to be. There are definitely better ways to write some of this code. We will try to be open with what trade-offs we made or any deficiencies we see.\nHaving said that we love feedback. We are absolutely interested in hearing better ways of writing code and if we think your way is better we guarantee it will go into the product. Software architecture is hard. We can\u0026rsquo;t stay on top of everything and feedback is the shortest path to knowing what needs improvement.\n"
},
{
	"uri": "/documentation/account/",
	"title": "Subscription",
	"tags": [],
	"description": "",
	"content": "Subscriptions are billed monthly.\nYou can manage your subscription by logging in here\nYou can also email support any time to inquire about purchasing a subscription or help with upgrading or cancelling your subscription.\n"
},
{
	"uri": "/documentation/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]